!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("three")):"function"==typeof define&&define.amd?define(["exports","three"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self)["Gaussian Splats 3D"]=e["Gaussian Splats 3D"]||{},e.THREE)}(this,(function(e,t){"use strict";function n(e){var t=Object.create(null);return e&&Object.keys(e).forEach((function(n){if("default"!==n){var s=Object.getOwnPropertyDescriptor(e,n);Object.defineProperty(t,n,s.get?s:{enumerable:!0,get:function(){return e[n]}})}})),t.default=e,Object.freeze(t)}var s=n(t);class r{static OFFSET={X:0,Y:1,Z:2,SCALE0:3,SCALE1:4,SCALE2:5,ROTATION0:6,ROTATION1:7,ROTATION2:8,ROTATION3:9,FDC0:10,FDC1:11,FDC2:12,OPACITY:13};constructor(){this.splats=[],this.splatCount=0}static createSplat(){return[0,0,0,1,1,1,1,0,0,0,0,0,0,0]}addSplat(e){this.splats.push(e),this.splatCount++}getSplat(e){return this.splats[e]}addDefaultSplat(){const e=r.createSplat();return this.addSplat(e),e}addSplatFromComonents(e,t,n,s,r,o,i,a,l,c,d,h,u,p){const m=[e,t,n,s,r,o,i,a,l,c,d,h,u,p];return this.addSplat(m),m}addSplatFromArray(e,t){const n=e.splats[t];this.addSplatFromComonents(n[0],n[1],n[2],n[3],n[4],n[5],n[6],n[7],n[8],n[9],n[10],n[11],n[12],n[13])}}class o{static idGen=0;constructor(e,t){let n,s;this.promise=new Promise(((e,t)=>{n=e.bind(this),s=t.bind(this)}));e(((...e)=>{n(...e)}).bind(this),(e=>{s(e)}).bind(this)),this.abortHandler=t,this.id=o.idGen++}then(e){return new o(((t,n)=>{this.promise=this.promise.then(((...n)=>{const s=e(...n);s instanceof Promise||s instanceof o?s.then(((...e)=>{t(...e)})):t(s)})).catch((e=>{n(e)}))}),this.abortHandler)}catch(e){return new o((t=>{this.promise=this.promise.then(((...e)=>{t(...e)})).catch(e)}),this.abortHandler)}abort(){this.abortHandler&&this.abortHandler()}}class i extends Error{constructor(e){super(e)}}!function(){const e=new Float32Array(1),t=new Int32Array(e.buffer)}();const a=function(){const e=new Float32Array(1),t=new Int32Array(e.buffer);return function(n){return e[0]=n,t[0]}}(),l=function(e,t,n=!0){const s=new AbortController,r=s.signal;let a=!1,l=null;return new o(((s,o)=>{l=o,fetch(e,{signal:r}).then((async e=>{const r=e.body.getReader();let i=0,l=e.headers.get("Content-Length"),c=l?parseInt(l):void 0;const d=[];for(;!a;)try{const{value:e,done:o}=await r.read();if(o){if(t&&t(100,"100%",e,c),n){const e=new Blob(d).arrayBuffer();s(e)}else s();break}let a,l;if(i+=e.length,void 0!==c&&(a=i/c*100,l=`${a.toFixed(2)}%`),n&&d.push(e),t){t(a,l,e,c)&&(n=!1)}}catch(e){o(e);break}}))}),(()=>{s.abort(),l(new i("Fetch aborted.")),a=!0}))},c=function(e,t,n){return Math.max(Math.min(e,n),t)},d=function(){return performance.now()/1e3},h=e=>{if(e.geometry&&(e.geometry.dispose(),e.geometry=null),e.material&&(e.material.dispose(),e.material=null),e.children)for(let t of e.children)h(t)},u=e=>new Promise((t=>{window.setTimeout((()=>{t(e())}),1)}));class p{static CurrentMajorVersion=0;static CurrentMinorVersion=1;static CenterComponentCount=3;static ScaleComponentCount=3;static RotationComponentCount=4;static ColorComponentCount=4;static CovarianceComponentCount=6;static SplatScaleOffsetFloat=3;static SplatRotationOffsetFloat=6;static CompressionLevels={0:{BytesPerCenter:12,BytesPerColor:4,BytesPerScale:12,BytesPerRotation:16,BytesPerSplat:44,ScaleRange:1},1:{BytesPerCenter:6,BytesPerColor:4,BytesPerScale:6,BytesPerRotation:8,BytesPerSplat:24,ScaleRange:32767}};static CovarianceSizeFloats=6;static HeaderSizeBytes=4096;static SectionHeaderSizeBytes=1024;static BucketStorageSizeBytes=12;static BucketStorageSizeFloats=3;static BucketBlockSize=5;static BucketSize=256;constructor(e,t=!0){this.constructFromBuffer(e,t)}fbf(e){return 0===this.compressionLevel?e:s.DataUtils.fromHalfFloat(e)}getSplatCount(){return this.splatCount}getMaxSplatCount(){return this.maxSplatCount}getBucketIndex(e,t){let n;const s=e.fullBucketCount*e.bucketSize;if(t<s)n=Math.floor(t/e.bucketSize);else{let r=s;n=e.fullBucketCount;let o=0;for(;r<e.splatCount;){let s=e.partiallyFilledBucketLengths[o];if(t>=r&&t<r+s)break;r+=s,n++,o++}}return n}getSplatCenter(e,t,n){const s=this.globalSplatIndexToSectionMap[e],r=this.sections[s],o=e-r.splatCountOffset;if(1===this.compressionLevel){const e=o*this.uint16PerSplat,n=this.getBucketIndex(r,o)*p.BucketStorageSizeFloats,s=r.compressionScaleFactor,i=r.compressionScaleRange;t.x=(r.dataArrayUint16[e]-i)*s+r.bucketArray[n],t.y=(r.dataArrayUint16[e+1]-i)*s+r.bucketArray[n+1],t.z=(r.dataArrayUint16[e+2]-i)*s+r.bucketArray[n+2]}else{const e=o*this.float32PerSplat;t.x=r.dataArrayFloat32[e],t.y=r.dataArrayFloat32[e+1],t.z=r.dataArrayFloat32[e+2]}n&&t.applyMatrix4(n)}getSplatScaleAndRotation=function(){const e=new s.Matrix4,t=new s.Matrix4,n=new s.Matrix4,r=new s.Vector3;return function(s,o,i,a){const l=this.globalSplatIndexToSectionMap[s],c=this.sections[l],d=s-c.splatCountOffset,h=1===this.compressionLevel?this.uint16PerSplat:this.float32PerSplat,u=1===this.compressionLevel?c.dataArrayUint16:c.dataArrayFloat32,m=h*d,f=m+p.SplatScaleOffsetFloat;o.set(this.fbf(u[f]),this.fbf(u[f+1]),this.fbf(u[f+2]));const g=m+p.SplatRotationOffsetFloat;i.set(this.fbf(u[g+1]),this.fbf(u[g+2]),this.fbf(u[g+3]),this.fbf(u[g])),a&&(e.makeScale(o.x,o.y,o.z),t.makeRotationFromQuaternion(i),n.copy(e).multiply(t).multiply(a),n.decompose(r,i,o))}}();getSplatColor(e,t,n){const s=this.globalSplatIndexToSectionMap[e],r=this.sections[s],o=e-r.splatCountOffset,i=this.bytesPerSplat*o+this.bytesPerCenter+this.bytesPerScale+this.bytesPerRotation;t.set(r.dataArrayUint8[i],r.dataArrayUint8[i+1],r.dataArrayUint8[i+2],r.dataArrayUint8[i+3])}fillSplatCenterArray(e,t,n,r,o){const i=this.splatCount;n=n||0,r=r||i-1,void 0===o&&(o=n);const a=new s.Vector3;for(let s=n;s<=r;s++){const r=this.globalSplatIndexToSectionMap[s],i=this.sections[r],l=s-i.splatCountOffset,c=(s-n+o)*p.CenterComponentCount;if(1===this.compressionLevel){const e=l*this.uint16PerSplat,t=this.getBucketIndex(i,l)*p.BucketStorageSizeFloats,n=i.compressionScaleFactor,s=i.compressionScaleRange;a.x=(i.dataArrayUint16[e]-s)*n+i.bucketArray[t],a.y=(i.dataArrayUint16[e+1]-s)*n+i.bucketArray[t+1],a.z=(i.dataArrayUint16[e+2]-s)*n+i.bucketArray[t+2]}else{const e=l*this.float32PerSplat;a.x=i.dataArrayFloat32[e],a.y=i.dataArrayFloat32[e+1],a.z=i.dataArrayFloat32[e+2]}t&&a.applyMatrix4(t),e[c]=a.x,e[c+1]=a.y,e[c+2]=a.z}}static computeCovariance=function(){const e=new s.Matrix4,t=new s.Matrix3,n=new s.Matrix3,r=new s.Matrix3,o=new s.Matrix3,i=new s.Matrix3,a=new s.Matrix3,l=s.DataUtils.toHalfFloat.bind(s.DataUtils);return function(s,c,d,h,u=0,p){e.makeScale(s.x,s.y,s.z),t.setFromMatrix4(e),e.makeRotationFromQuaternion(c),n.setFromMatrix4(e),r.copy(n).multiply(t),o.copy(r).transpose().premultiply(r),d&&(i.setFromMatrix4(d),a.copy(i).transpose(),o.multiply(a),o.premultiply(i)),1===p?(h[u]=l(o.elements[0]),h[u+1]=l(o.elements[3]),h[u+2]=l(o.elements[6]),h[u+3]=l(o.elements[4]),h[u+4]=l(o.elements[7]),h[u+5]=l(o.elements[8])):(h[u]=o.elements[0],h[u+1]=o.elements[3],h[u+2]=o.elements[6],h[u+3]=o.elements[4],h[u+4]=o.elements[7],h[u+5]=o.elements[8])}}();fillSplatCovarianceArray(e,t,n,r,o,i){const a=this.splatCount,l=new s.Vector3,c=new s.Quaternion;n=n||0,r=r||a-1,void 0===o&&(o=n);const d=1===this.compressionLevel?this.uint16PerSplat:this.float32PerSplat;for(let s=n;s<=r;s++){const r=this.globalSplatIndexToSectionMap[s],a=this.sections[r],h=s-a.splatCountOffset,u=1===this.compressionLevel?a.dataArrayUint16:a.dataArrayFloat32,m=d*h,f=(s-n+o)*p.CovarianceComponentCount,g=m+p.SplatScaleOffsetFloat;l.set(this.fbf(u[g]),this.fbf(u[g+1]),this.fbf(u[g+2]));const S=m+p.SplatRotationOffsetFloat;c.set(this.fbf(u[S+1]),this.fbf(u[S+2]),this.fbf(u[S+3]),this.fbf(u[S])),p.computeCovariance(l,c,t,e,f,i)}}fillSplatColorArray(e,t,n,s,r,o){const i=this.splatCount;s=s||0,r=r||i-1,void 0===o&&(o=s);const a=this.bytesPerCenter+this.bytesPerScale+this.bytesPerRotation;for(let n=s;n<=r;n++){const r=this.globalSplatIndexToSectionMap[n],i=this.sections[r],l=n-i.splatCountOffset,c=this.bytesPerSplat*l+a,d=(n-s+o)*p.ColorComponentCount;let h=i.dataArrayUint8[c+3];h=h>=t?h:0,e[d]=i.dataArrayUint8[c],e[d+1]=i.dataArrayUint8[c+1],e[d+2]=i.dataArrayUint8[c+2],e[d+3]=h}}static parseHeader(e){const t=new Uint8Array(e,0,p.HeaderSizeBytes),n=new Uint16Array(e,0,p.HeaderSizeBytes/2),r=new Uint32Array(e,0,p.HeaderSizeBytes/4),o=new Float32Array(e,0,p.HeaderSizeBytes/4);return{versionMajor:t[0],versionMinor:t[1],maxSectionCount:r[1],sectionCount:r[2],maxSplatCount:r[3],splatCount:r[4],compressionLevel:n[10],sceneCenter:new s.Vector3(o[6],o[7],o[8])}}static writeHeaderCountsToBuffer(e,t,n){const s=new Uint32Array(n);s[2]=e,s[4]=t}static writeHeaderToBuffer(e,t){const n=new Uint8Array(t),s=new Uint32Array(t),r=new Float32Array(t),o=new Uint16Array(t);n[0]=e.versionMajor,n[1]=e.versionMinor,n[2]=0,n[3]=0,s[1]=e.maxSectionCount,s[2]=e.sectionCount,s[3]=e.maxSplatCount,s[4]=e.splatCount,o[10]=e.compressionLevel,r[6]=e.sceneCenter.x,r[7]=e.sceneCenter.y,r[8]=e.sceneCenter.z}static parseSectionHeaders(e,t,n=0,s){const r=e.compressionLevel,o=p.CompressionLevels[r].BytesPerCenter,i=p.CompressionLevels[r].BytesPerColor,a=p.CompressionLevels[r].BytesPerScale,l=p.CompressionLevels[r].BytesPerRotation,c=e.maxSectionCount,d=new Uint16Array(t,n,c*p.SectionHeaderSizeBytes/2),h=new Uint32Array(t,n,c*p.SectionHeaderSizeBytes/4),u=new Float32Array(t,n,c*p.SectionHeaderSizeBytes/4),m=[];let f=0,g=f/2,S=f/4,y=p.HeaderSizeBytes+e.maxSectionCount*p.SectionHeaderSizeBytes,A=0;for(let e=0;e<c;e++){const t=h[S+1],n=h[S+2],c=h[S+3],C=u[S+4],x=C/2,b=d[g+10],w=h[S+6]||p.CompressionLevels[r].ScaleRange,T=h[S+8],v=h[S+9],F=4*v,M=b*c+F,B=(o+a+l+i)*t,E=B+M,P={splatCountOffset:A,splatCount:s?t:0,maxSplatCount:t,bucketSize:n,bucketCount:c,bucketBlockSize:C,halfBucketBlockSize:x,bucketStorageSizeBytes:b,bucketsStorageSizeBytes:M,splatDataStorageSizeBytes:B,storageSizeBytes:E,compressionScaleRange:w,compressionScaleFactor:x/w,base:y,bucketsBase:y+F,dataBase:y+M,fullBucketCount:T,partiallyFilledBucketCount:v};m[e]=P,y+=E,f+=p.SectionHeaderSizeBytes,g=f/2,S=f/4,A+=t}return m}static writeSectionHeaderToBuffer(e,t,n,s=0){const r=new Uint16Array(n,s,p.SectionHeaderSizeBytes/2),o=new Uint32Array(n,s,p.SectionHeaderSizeBytes/4),i=new Float32Array(n,s,p.SectionHeaderSizeBytes/4);o[0]=e.splatCount,o[1]=e.maxSplatCount,o[2]=1===t?e.bucketSize:0,o[3]=1===t?e.bucketCount:0,i[4]=1===t?e.bucketBlockSize:0,r[10]=1===t?p.BucketStorageSizeBytes:0,o[6]=1===t?e.compressionScaleRange:0,o[7]=e.storageSizeBytes,o[8]=1===t?e.fullBucketCount:0,o[9]=1===t?e.partiallyFilledBucketCount:0}static writeSectionHeaderSplatCountToBuffer(e,t,n=0){new Uint32Array(t,n,p.SectionHeaderSizeBytes/4)[0]=e}constructFromBuffer(e,t){this.bufferData=e,this.globalSplatIndexToLocalSplatIndexMap=[],this.globalSplatIndexToSectionMap=[];const n=p.parseHeader(this.bufferData);this.versionMajor=n.versionMajor,this.versionMinor=n.versionMinor,this.maxSectionCount=n.maxSectionCount,this.sectionCount=t?n.maxSectionCount:0,this.maxSplatCount=n.maxSplatCount,this.splatCount=t?n.maxSplatCount:0,this.compressionLevel=n.compressionLevel,this.sceneCenter=(new s.Vector3).copy(n.sceneCenter),this.bytesPerCenter=p.CompressionLevels[this.compressionLevel].BytesPerCenter,this.bytesPerScale=p.CompressionLevels[this.compressionLevel].BytesPerScale,this.bytesPerRotation=p.CompressionLevels[this.compressionLevel].BytesPerRotation,this.bytesPerColor=p.CompressionLevels[this.compressionLevel].BytesPerColor,this.bytesPerSplat=this.bytesPerCenter+this.bytesPerScale+this.bytesPerRotation+this.bytesPerColor,this.float32PerSplat=this.bytesPerSplat/4,this.uint32PerSplat=this.bytesPerSplat/4,this.uint16PerSplat=this.bytesPerSplat/2,this.sections=p.parseSectionHeaders(n,this.bufferData,p.HeaderSizeBytes,t),this.linkBufferArrays(),this.buildMaps()}linkBufferArrays(){for(let e=0;e<this.maxSectionCount;e++){const t=this.sections[e];t.dataArrayUint8=new Uint8Array(this.bufferData,t.dataBase,t.maxSplatCount*this.bytesPerSplat),t.dataArrayUint16=new Uint16Array(this.bufferData,t.dataBase,t.maxSplatCount*this.uint16PerSplat),t.dataArrayUint32=new Uint32Array(this.bufferData,t.dataBase,t.maxSplatCount*this.uint32PerSplat),t.dataArrayFloat32=new Float32Array(this.bufferData,t.dataBase,t.maxSplatCount*this.float32PerSplat),t.bucketArray=new Float32Array(this.bufferData,t.bucketsBase,t.bucketCount*p.BucketStorageSizeFloats),t.partiallyFilledBucketCount>0&&(t.partiallyFilledBucketLengths=new Uint32Array(this.bufferData,t.base,t.partiallyFilledBucketCount))}}buildMaps(){let e=0;for(let t=0;t<this.maxSectionCount;t++){const n=this.sections[t];for(let s=0;s<n.maxSplatCount;s++){const n=e+s;this.globalSplatIndexToLocalSplatIndexMap[n]=s,this.globalSplatIndexToSectionMap[n]=t}e+=n.maxSplatCount}}updateLoadedCounts(e,t){p.writeHeaderCountsToBuffer(e,t,this.bufferData),this.sectionCount=e,this.splatCount=t}updateSectionLoadedCounts(e,t){const n=p.HeaderSizeBytes+p.SectionHeaderSizeBytes*e;p.writeSectionHeaderSplatCountToBuffer(t,this.bufferData,n),this.sections[e].splatCount=t}static generateFromUncompressedSplatArrays(e,t,n,o,i,a,l=[]){const d=p.CompressionLevels[n].BytesPerCenter,h=p.CompressionLevels[n].BytesPerScale,u=p.CompressionLevels[n].BytesPerRotation,m=d+h+u+p.CompressionLevels[n].BytesPerColor,f=p.CompressionLevels[n].ScaleRange,g=[],S=[];let y=0;const A=new s.Quaternion,C=s.DataUtils.toHalfFloat.bind(s.DataUtils);for(let o=0;o<e.length;o++){const x=e[o],b=l[o]||{},w=(b.blockSizeFactor||1)*(i||p.BucketBlockSize),T=Math.ceil((b.bucketSizeFactor||1)*(a||p.BucketSize)),v=new r;for(let e=0;e<x.splatCount;e++){const n=x.splats[e];let s;s=n[r.OFFSET.OPACITY]?n[r.OFFSET.OPACITY]:255,s>=t&&v.addSplatFromComonents(n[r.OFFSET.X],n[r.OFFSET.Y],n[r.OFFSET.Z],n[r.OFFSET.SCALE0],n[r.OFFSET.SCALE1],n[r.OFFSET.SCALE2],n[r.OFFSET.ROTATION0],n[r.OFFSET.ROTATION1],n[r.OFFSET.ROTATION2],n[r.OFFSET.ROTATION3],n[r.OFFSET.FDC0],n[r.OFFSET.FDC1],n[r.OFFSET.FDC2],n[r.OFFSET.OPACITY])}const F=p.computeBucketsForUncompressedSplatArray(v,w,T),M=F.fullBuckets.length,B=F.partiallyFullBuckets.map((e=>e.splats.length)),E=B.length,P=[...F.fullBuckets,...F.partiallyFullBuckets],I=v.splats.length*m,D=4*E,R=1===n?P.length*p.BucketStorageSizeBytes+D:0,k=I+R,O=new ArrayBuffer(k),L=f/(w/2),z=2*f+1,U=new s.Vector3,_=new s.Vector3;let V=0;for(let e=0;e<P.length;e++){const t=P[e];U.fromArray(t.center);for(let e=0;e<t.splats.length;e++){let s=t.splats[e];const o=v.splats[s],i=R+V*m,a=i+d,l=a+h,g=l+u;if(0===n){const e=new Float32Array(O,i,p.CenterComponentCount),t=new Float32Array(O,l,p.RotationComponentCount),n=new Float32Array(O,a,p.ScaleComponentCount);void 0!==o[r.OFFSET.SCALE0]?(A.set(o[r.OFFSET.ROTATION0],o[r.OFFSET.ROTATION1],o[r.OFFSET.ROTATION2],o[r.OFFSET.ROTATION3]),A.normalize(),t.set([A.x,A.y,A.z,A.w]),n.set([o[r.OFFSET.SCALE0],o[r.OFFSET.SCALE1],o[r.OFFSET.SCALE2]])):(t.set([1,0,0,0]),n.set([.01,.01,.01])),e.set([o[r.OFFSET.X],o[r.OFFSET.Y],o[r.OFFSET.Z]])}else{const e=new Uint16Array(O,i,p.CenterComponentCount),t=new Uint16Array(O,l,p.RotationComponentCount),n=new Uint16Array(O,a,p.ScaleComponentCount);void 0!==o[r.OFFSET.SCALE0]?(A.set(o[r.OFFSET.ROTATION0],o[r.OFFSET.ROTATION1],o[r.OFFSET.ROTATION2],o[r.OFFSET.ROTATION3]),A.normalize(),t.set([C(A.x),C(A.y),C(A.z),C(A.w)]),n.set([C(o[r.OFFSET.SCALE0]),C(o[r.OFFSET.SCALE1]),C(o[r.OFFSET.SCALE2])])):(t.set([C(1),0,0,0]),n.set([C(.01),C(.01),C(.01)])),_.set(o[r.OFFSET.X],o[r.OFFSET.Y],o[r.OFFSET.Z]).sub(U),_.x=Math.round(_.x*L)+f,_.x=c(_.x,0,z),_.y=Math.round(_.y*L)+f,_.y=c(_.y,0,z),_.z=Math.round(_.z*L)+f,_.z=c(_.z,0,z),e.set([_.x,_.y,_.z])}const S=new Uint8ClampedArray(O,g,4);void 0!==o[r.OFFSET.FDC0]?S.set([o[r.OFFSET.FDC0],o[r.OFFSET.FDC1],o[r.OFFSET.FDC2]]):S.set([255,0,0]),void 0!==o[r.OFFSET.OPACITY]?S[3]=o[r.OFFSET.OPACITY]:S[3]=255,V++}}if(y+=V,1===n){const e=new Uint32Array(O);for(let t=0;t<B.length;t++)e[t]=B[t];const t=new Float32Array(O,D,P.length*p.BucketStorageSizeFloats);for(let e=0;e<P.length;e++){const n=P[e],s=3*e;t[s]=n.center[0],t[s+1]=n.center[1],t[s+2]=n.center[2]}}g.push(O);const N=new ArrayBuffer(p.SectionHeaderSizeBytes);p.writeSectionHeaderToBuffer({maxSplatCount:V,splatCount:V,bucketSize:T,bucketCount:P.length,bucketBlockSize:w,compressionScaleRange:f,storageSizeBytes:k,fullBucketCount:M,partiallyFilledBucketCount:E},n,N,0),S.push(N)}let x=0;for(let e of g)x+=e.byteLength;const b=p.HeaderSizeBytes+p.SectionHeaderSizeBytes*g.length+x,w=new ArrayBuffer(b);p.writeHeaderToBuffer({versionMajor:0,versionMinor:1,maxSectionCount:g.length,sectionCount:g.length,maxSplatCount:y,splatCount:y,compressionLevel:n,sceneCenter:o},w);let T=p.HeaderSizeBytes;for(let e of S)new Uint8Array(w,T,p.SectionHeaderSizeBytes).set(new Uint8Array(e)),T+=p.SectionHeaderSizeBytes;for(let e of g)new Uint8Array(w,T,e.byteLength).set(new Uint8Array(e)),T+=e.byteLength;return new p(w)}static computeBucketsForUncompressedSplatArray(e,t,n){let o=e.splatCount;const i=t/2,a=new s.Vector3,l=new s.Vector3;for(let t=0;t<o;t++){const n=e.splats[t],s=[n[r.OFFSET.X],n[r.OFFSET.Y],n[r.OFFSET.Z]];(0===t||s[0]<a.x)&&(a.x=s[0]),(0===t||s[0]>l.x)&&(l.x=s[0]),(0===t||s[1]<a.y)&&(a.y=s[1]),(0===t||s[1]>l.y)&&(l.y=s[1]),(0===t||s[2]<a.z)&&(a.z=s[2]),(0===t||s[2]>l.z)&&(l.z=s[2])}const c=(new s.Vector3).copy(l).sub(a),d=Math.ceil(c.y/t),h=Math.ceil(c.z/t),u=new s.Vector3,p=[],m={};for(let s=0;s<o;s++){const o=e.splats[s],l=[o[r.OFFSET.X],o[r.OFFSET.Y],o[r.OFFSET.Z]],c=Math.floor((l[0]-a.x)/t),f=Math.floor((l[1]-a.y)/t),g=Math.floor((l[2]-a.z)/t);u.x=c*t+a.x+i,u.y=f*t+a.y+i,u.z=g*t+a.z+i;const S=c*(d*h)+f*h+g;let y=m[S];y||(m[S]=y={splats:[],center:u.toArray()}),y.splats.push(s),y.splats.length>=n&&(p.push(y),m[S]=null)}const f=[];for(let e in m)if(m.hasOwnProperty(e)){const t=m[e];t&&f.push(t)}return{fullBuckets:p,partiallyFullBuckets:f}}}const m=new Uint8Array([112,108,121,10]),f=new Uint8Array([10,101,110,100,95,104,101,97,100,101,114,10]),g="end_header",S=new Map([["char",Int8Array],["uchar",Uint8Array],["short",Int16Array],["ushort",Uint16Array],["int",Int32Array],["uint",Uint32Array],["float",Float32Array],["double",Float64Array]]),y=(e,t)=>{const n=(1<<t)-1;return(e&n)/n},A=(e,t)=>{e.x=y(t>>>21,11),e.y=y(t>>>11,10),e.z=y(t,11)},C=(e,t,n)=>e*(1-n)+t*n,x=(e,t)=>e.properties.find((e=>e.name===t&&e.storage))?.storage;class b{static decodeHeaderText(e){let t,n,s;const r=e.split("\n").filter((e=>!e.startsWith("comment ")));let o=0,i=!1;for(let e=1;e<r.length;++e){const a=r[e].split(" ");switch(a[0]){case"format":if("binary_little_endian"!==a[1])throw new Error("Unsupported ply format");break;case"element":t={name:a[1],count:parseInt(a[2],10),properties:[],storageSizeBytes:0},"chunk"===t.name?n=t:"vertex"===t.name&&(s=t);break;case"property":{if(!S.has(a[1]))throw new Error(`Unrecognized property data type '${a[1]}' in ply header`);const e=S.get(a[1]),n=e.BYTES_PER_ELEMENT*t.count;"vertex"===t.name&&(o+=e.BYTES_PER_ELEMENT),t.properties.push({type:a[1],name:a[2],storage:null,byteSize:e.BYTES_PER_ELEMENT,storageSizeByes:n}),t.storageSizeBytes+=n;break}case g:i=!0;break;default:throw new Error(`Unrecognized header value '${a[0]}' in ply header`)}if(i)break}return{chunkElement:n,vertexElement:s,bytesPerSplat:o,headerSizeBytes:e.indexOf(g)+10+1}}static decodeHeader(e){let t,n=new Uint8Array(e);if(n.length>=m.length&&!((e,t)=>{if(e.length<t.length)return!1;for(let n=0;n<t.length;++n)if(e[n]!==t[n])return!1;return!0})(n,m))throw new Error("Invalid PLY header");if(t=((e,t)=>{const n=e.length-t.length;let s,r;for(s=0;s<=n;++s){for(r=0;r<t.length&&e[s+r]===t[r];++r);if(r===t.length)return s}return-1})(n,f),-1===t)throw new Error("End of PLY header not found");const s=new TextDecoder("ascii").decode(n.slice(0,t)),{chunkElement:r,vertexElement:o,bytesPerSplat:i}=b.decodeHeaderText(s);return{headerSizeBytes:t+f.length,bytesPerSplat:i,chunkElement:r,vertexElement:o}}static readElementData(e,t,n,s,r,o=null){let i=t instanceof DataView?t:new DataView(t);s=s||0,r=r||e.count-1;for(let t=s;t<=r;++t)for(let s=0;s<e.properties.length;++s){const r=e.properties[s],a=S.get(r.type),l=a.BYTES_PER_ELEMENT*e.count;if(r.storage&&!(r.storage.byteLength<l)||o&&!o(r.name)||(r.storage=new a(e.count)),r.storage)switch(r.type){case"char":r.storage[t]=i.getInt8(n);break;case"uchar":r.storage[t]=i.getUint8(n);break;case"short":r.storage[t]=i.getInt16(n,!0);break;case"ushort":r.storage[t]=i.getUint16(n,!0);break;case"int":r.storage[t]=i.getInt32(n,!0);break;case"uint":r.storage[t]=i.getUint32(n,!0);break;case"float":r.storage[t]=i.getFloat32(n,!0);break;case"double":r.storage[t]=i.getFloat64(n,!0)}n+=r.byteSize}return n}static readPly(e,t=null){const n=b.decodeHeader(e);let s=b.readElementData(n.chunkElement,e,n.headerSizeBytes,null,null,t);return b.readElementData(n.vertexElement,e,s,null,null,t),{chunkElement:n.chunkElement,vertexElement:n.vertexElement}}static getElementStorageArrays(e,t){const n=x(e,"min_x"),s=x(e,"min_y"),r=x(e,"min_z"),o=x(e,"max_x"),i=x(e,"max_y"),a=x(e,"max_z"),l=x(e,"min_scale_x"),c=x(e,"min_scale_y"),d=x(e,"min_scale_z");return{positionExtremes:{minX:n,maxX:o,minY:s,maxY:i,minZ:r,maxZ:a},scaleExtremes:{minScaleX:l,maxScaleX:x(e,"max_scale_x"),minScaleY:c,maxScaleY:x(e,"max_scale_y"),minScaleZ:d,maxScaleZ:x(e,"max_scale_z")},position:x(t,"packed_position"),rotation:x(t,"packed_rotation"),scale:x(t,"packed_scale"),color:x(t,"packed_color")}}static decompressSplat=function(){const e=new s.Vector3,t=new s.Quaternion,n=new s.Vector3,o=new s.Vector4,i=r.OFFSET;return function(s,a,l,d,h,u,p,m,f){f=f||r.createSplat();const g=Math.floor((a+s)/256);var S,x;return A(e,l[s]),((e,t)=>{const n=1/(.5*Math.sqrt(2)),s=(y(t>>>20,10)-.5)*n,r=(y(t>>>10,10)-.5)*n,o=(y(t,10)-.5)*n,i=Math.sqrt(1-(s*s+r*r+o*o));switch(t>>>30){case 0:e.set(i,s,r,o);break;case 1:e.set(s,i,r,o);break;case 2:e.set(s,r,i,o);break;case 3:e.set(s,r,o,i)}})(t,p[s]),A(n,h[s]),S=o,x=m[s],S.x=y(x>>>24,8),S.y=y(x>>>16,8),S.z=y(x>>>8,8),S.w=y(x,8),f[i.X]=C(d.minX[g],d.maxX[g],e.x),f[i.Y]=C(d.minY[g],d.maxY[g],e.y),f[i.Z]=C(d.minZ[g],d.maxZ[g],e.z),f[i.ROTATION0]=t.x,f[i.ROTATION1]=t.y,f[i.ROTATION2]=t.z,f[i.ROTATION3]=t.w,f[i.SCALE0]=Math.exp(C(u.minScaleX[g],u.maxScaleX[g],n.x)),f[i.SCALE1]=Math.exp(C(u.minScaleY[g],u.maxScaleY[g],n.y)),f[i.SCALE2]=Math.exp(C(u.minScaleZ[g],u.maxScaleZ[g],n.z)),f[i.FDC0]=c(Math.floor(255*o.x),0,255),f[i.FDC1]=c(Math.floor(255*o.y),0,255),f[i.FDC2]=c(Math.floor(255*o.z),0,255),f[i.OPACITY]=c(Math.floor(255*o.w),0,255),f}}();static parseToUncompressedSplatBufferSection(e,t,n,s,o,i,a,l,c,d=null){b.readElementData(t,i,a,n,s,d);const h=p.CompressionLevels[0].BytesPerCenter,u=p.CompressionLevels[0].BytesPerScale,m=p.CompressionLevels[0].BytesPerRotation,f=p.CompressionLevels[0].BytesPerSplat,{positionExtremes:g,scaleExtremes:S,position:y,rotation:A,scale:C,color:x}=b.getElementStorageArrays(e,t),w=r.OFFSET,T=r.createSplat();for(let e=n;e<=s;++e){b.decompressSplat(e,o,y,g,C,S,A,x,T);const t=e*f+c,n=new Float32Array(l,t,3),s=new Float32Array(l,t+h,3),r=new Float32Array(l,t+h+u,4),i=new Uint8Array(l,t+h+u+m,4);n[0]=T[w.X],n[1]=T[w.Y],n[2]=T[w.Z],s[0]=T[w.SCALE0],s[1]=T[w.SCALE1],s[2]=T[w.SCALE2],r[0]=T[w.ROTATION0],r[1]=T[w.ROTATION1],r[2]=T[w.ROTATION2],r[3]=T[w.ROTATION3],i[0]=T[w.FDC0],i[1]=T[w.FDC1],i[2]=T[w.FDC2],i[3]=T[w.OPACITY]}}static parseToUncompressedSplatArray(e){const{chunkElement:t,vertexElement:n}=b.readPly(e),o=new r,{positionExtremes:i,scaleExtremes:a,position:l,rotation:c,scale:d,color:h}=b.getElementStorageArrays(t,n);for(let e=0;e<n.count;++e){o.addDefaultSplat();const t=o.getSplat(o.splatCount-1);b.decompressSplat(e,0,l,i,d,a,c,h,t)}return(new s.Matrix4).identity(),o}}class w{static HeaderEndToken="end_header";static Fields=["scale_0","scale_1","scale_2","rot_0","rot_1","rot_2","rot_3","x","y","z","f_dc_0","f_dc_1","f_dc_2","red","green","blue","opacity"];static checkTextForEndHeader(e){return!!e.includes(w.HeaderEndToken)}static checkBufferForEndHeader(e,t,n,s){const r=new Uint8Array(e,Math.max(0,t-n),n),o=s.decode(r);return w.checkTextForEndHeader(o)}static decodeHeaderText(e){const t=e.split("\n"),n=[];let s=0,r={},o=!1;for(let e=0;e<t.length;e++){const i=t[e].trim();if(n.push(i),i.startsWith("element chunk")||i.match(/[A-Za-z]*packed_[A-Za-z]*/))o=!0;else if(i.startsWith("element vertex")){const e=i.match(/\d+/);e&&(s=parseInt(e[0]))}else if(i.startsWith("property")){const e=i.match(/(\w+)\s+(\w+)\s+(\w+)/);if(e){const t=e[2];r[e[3]]=t}}else if(i===w.HeaderEndToken)break}let i=0,a={};const l={double:8,int:4,uint:4,float:4,short:2,ushort:2,uchar:1};for(let e in r)if(r.hasOwnProperty(e)){const t=r[e];a[e]=i,i+=l[t]}return{splatCount:s,propertyTypes:r,compressed:o,headerText:e,headerLines:n,headerSizeBytes:e.indexOf(w.HeaderEndToken)+w.HeaderEndToken.length+1,bytesPerSplat:i,fieldOffsets:a}}static decodeHeadeFromBuffer(e){const t=new TextDecoder;let n=0,s="";const r=100;for(;;){if(n+r>=e.byteLength)throw new Error("End of file reached while searching for end of header");const o=new Uint8Array(e,n,r);if(s+=t.decode(o),n+=r,w.checkBufferForEndHeader(e,n,200,t))break}return w.decodeHeaderText(s)}static findVertexData(e,t){return new DataView(e,t.headerSizeBytes)}static readRawVertexFast(e,t,n,s,r,o){let i=o||{};for(let o of s){const s=r[o];"float"===s?i[o]=e.getFloat32(t+n[o],!0):"uchar"===s&&(i[o]=e.getUint8(t+n[o])/255)}}static parseToUncompressedSplatBufferSection(e,t,n,s,o,i,a){const l=p.CompressionLevels[0].BytesPerCenter,c=p.CompressionLevels[0].BytesPerScale,d=p.CompressionLevels[0].BytesPerRotation,h=p.CompressionLevels[0].BytesPerSplat;for(let u=t;u<=n;u++){const t=w.parseToUncompressedSplat(s,u,e,o),n=u*h+a,p=new Float32Array(i,n,3),m=new Float32Array(i,n+l,3),f=new Float32Array(i,n+l+c,4),g=new Uint8Array(i,n+l+c+d,4);p[0]=t[r.OFFSET.X],p[1]=t[r.OFFSET.Y],p[2]=t[r.OFFSET.Z],m[0]=t[r.OFFSET.SCALE0],m[1]=t[r.OFFSET.SCALE1],m[2]=t[r.OFFSET.SCALE2],f[0]=t[r.OFFSET.ROTATION0],f[1]=t[r.OFFSET.ROTATION1],f[2]=t[r.OFFSET.ROTATION2],f[3]=t[r.OFFSET.ROTATION3],g[0]=t[r.OFFSET.FDC0],g[1]=t[r.OFFSET.FDC1],g[2]=t[r.OFFSET.FDC2],g[3]=t[r.OFFSET.OPACITY]}}static parseToUncompressedSplat=function(){let e={};const t=new s.Quaternion;return function(n,s,o,i=0){w.readRawVertexFast(n,s*o.bytesPerSplat+i,o.fieldOffsets,w.Fields,o.propertyTypes,e);const a=r.createSplat();if(void 0!==e.scale_0?(a[r.OFFSET.SCALE0]=Math.exp(e.scale_0),a[r.OFFSET.SCALE1]=Math.exp(e.scale_1),a[r.OFFSET.SCALE2]=Math.exp(e.scale_2)):(a[r.OFFSET.SCALE0]=.01,a[r.OFFSET.SCALE1]=.01,a[r.OFFSET.SCALE2]=.01),void 0!==e.f_dc_0){const t=.28209479177387814;a[r.OFFSET.FDC0]=255*(.5+t*e.f_dc_0),a[r.OFFSET.FDC1]=255*(.5+t*e.f_dc_1),a[r.OFFSET.FDC2]=255*(.5+t*e.f_dc_2)}else void 0!==e.red?(a[r.OFFSET.FDC0]=255*e.red,a[r.OFFSET.FDC1]=255*e.green,a[r.OFFSET.FDC2]=255*e.blue):(a[r.OFFSET.FDC0]=0,a[r.OFFSET.FDC1]=0,a[r.OFFSET.FDC2]=0);return void 0!==e.opacity&&(a[r.OFFSET.OPACITY]=1/(1+Math.exp(-e.opacity))*255),a[r.OFFSET.FDC0]=c(Math.floor(a[r.OFFSET.FDC0]),0,255),a[r.OFFSET.FDC1]=c(Math.floor(a[r.OFFSET.FDC1]),0,255),a[r.OFFSET.FDC2]=c(Math.floor(a[r.OFFSET.FDC2]),0,255),a[r.OFFSET.OPACITY]=c(Math.floor(a[r.OFFSET.OPACITY]),0,255),t.set(e.rot_0,e.rot_1,e.rot_2,e.rot_3),t.normalize(),a[r.OFFSET.ROTATION0]=t.x,a[r.OFFSET.ROTATION1]=t.y,a[r.OFFSET.ROTATION2]=t.z,a[r.OFFSET.ROTATION3]=t.w,a[r.OFFSET.X]=e.x,a[r.OFFSET.Y]=e.y,a[r.OFFSET.Z]=e.z,a}}();static parseToUncompressedSplatArray(e){const t=w.decodeHeadeFromBuffer(e);if(t.compressed)return b.parseToUncompressedSplatArray(e);{const n=t.splatCount,s=w.findVertexData(e,t),o=new r;for(let e=0;e<n;e++){const n=w.parseToUncompressedSplat(s,e,t);o.addSplat(n)}return o}}}class T{constructor(e,t,n,s){this.sectionCount=e,this.sectionFilters=t,this.groupingParameters=n,this.partitionGenerator=s}partitionUncompressedSplatArray(e){let t,n,s;if(this.partitionGenerator){const r=this.partitionGenerator(e);t=r.groupingParameters,n=r.sectionCount,s=r.sectionFilters}else t=this.groupingParameters,n=this.sectionCount,s=this.sectionFilters;const o=[];for(let t=0;t<n;t++){const n=new r,i=s[t];for(let t=0;t<e.splatCount;t++)i(t)&&n.addSplatFromArray(e,t);o.push(n)}return{splatArrays:o,parameters:t}}static getStandardPartitioner(e=0,t=new s.Vector3,n=p.BucketBlockSize,o=p.BucketSize){return new T(void 0,void 0,void 0,(i=>{e<=0&&(e=i.splatCount);const a=new s.Vector3,l=new s.Vector3,c=.5,d=e=>{e.x=Math.floor(e.x/c)*c,e.y=Math.floor(e.y/c)*c,e.z=Math.floor(e.z/c)*c};i.splats.sort(((e,n)=>{a.set(e[r.OFFSET.X],e[r.OFFSET.Y],e[r.OFFSET.Z]).sub(t),d(a);const s=a.lengthSq();l.set(n[r.OFFSET.X],n[r.OFFSET.Y],n[r.OFFSET.Z]).sub(t),d(l);return s>l.lengthSq()?1:-1}));const h=[],u=[];e=Math.min(i.splatCount,e);const p=Math.ceil(i.splatCount/e);let m=0;for(let t=0;t<p;t++){let t=m;h.push((n=>n>=t&&n<t+e)),u.push({blocksSize:n,bucketSize:o}),m+=e}return{sectionCount:h.length,sectionFilters:h,groupingParameters:u}}))}}class v{constructor(e,t,n,r,o,i,a){this.splatPartitioner=e,this.alphaRemovalThreshold=t,this.compressionLevel=n,this.sectionSize=r,this.sceneCenter=o?(new s.Vector3).copy(o):void 0,this.blockSize=i,this.bucketSize=a}generateFromUncompressedSplatArray(e){const t=this.splatPartitioner.partitionUncompressedSplatArray(e);return p.generateFromUncompressedSplatArrays(t.splatArrays,this.alphaRemovalThreshold,this.compressionLevel,this.sceneCenter,this.blockSize,this.bucketSize,t.parameters)}static getStandardGenerator(e=1,t=1,n=0,r=new s.Vector3,o=p.BucketBlockSize,i=p.BucketSize){const a=T.getStandardPartitioner(n,r,o,i);return new v(a,e,t,n,r,o,i)}}const F=0,M=1,B=2;class E{static DepthMapRange=65536;static MemoryPageSize=65536;static BytesPerFloat=4;static BytesPerInt=4;static MaxScenes=32;static StreamingSectionSize=524288}function P(e,t){let n=0;for(let t of e)n+=t.sizeBytes;(!t||t.byteLength<n)&&(t=new ArrayBuffer(n));let s=0;for(let n of e)new Uint8Array(t,s,n.sizeBytes).set(n.data),s+=n.sizeBytes;return t}class I{static loadFromURL(e,t,n,r,o,i,a,c,d,h){const u=E.StreamingSectionSize,m=p.HeaderSizeBytes+p.SectionHeaderSizeBytes;let f,g,S,y,A,C=0,x=0,T=!1,v=!1,D=!1,R=new Promise((e=>{A=e})),k=0,O=0,L=0,z="",U=null,_=[];const V=new TextDecoder;return l(e,((e,o,i)=>{const a=e>=100;if(n){if(i&&(_.push({data:i,sizeBytes:i.byteLength,startBytes:L,endBytes:L+i.byteLength}),L+=i.byteLength),T){if(D&&!v){const e=U.headerSizeBytes+U.chunkElement.storageSizeBytes;y=P(_,y),y.byteLength>=e&&(b.readElementData(U.chunkElement,y,U.headerSizeBytes),k=e,O=e,v=!0)}}else if(z+=V.decode(i),w.checkTextForEndHeader(z)){U=w.decodeHeaderText(z),D=U.compressed,D?(U=b.decodeHeaderText(z),C=U.vertexElement.count):(C=U.splatCount,v=!0);const e=m+p.CompressionLevels[0].BytesPerSplat*C;g=new ArrayBuffer(e),p.writeHeaderToBuffer({versionMajor:p.CurrentMajorVersion,versionMinor:p.CurrentMinorVersion,maxSectionCount:1,sectionCount:1,maxSplatCount:C,splatCount:x,compressionLevel:0,sceneCenter:new s.Vector3},g),k=U.headerSizeBytes,O=U.headerSizeBytes,T=!0}if(T&&v){if(_.length>0){f=P(_,f);if(L-k>u||a){const e=L-O,t=Math.floor(e/U.bytesPerSplat),n=t*U.bytesPerSplat,s=e-n,o=x+t,i=O-_[0].startBytes,l=new DataView(f,i,n),c=x*p.CompressionLevels[0].BytesPerSplat+m;if(D?b.parseToUncompressedSplatBufferSection(U.chunkElement,U.vertexElement,0,t-1,x,l,0,g,c):w.parseToUncompressedSplatBufferSection(U,0,t-1,l,0,g,c),x=o,S||(p.writeSectionHeaderToBuffer({maxSplatCount:C,splatCount:x,bucketSize:0,bucketCount:0,bucketBlockSize:0,compressionScaleRange:0,storageSizeBytes:0,fullBucketCount:0,partiallyFilledBucketCount:0},0,g,p.HeaderSizeBytes),S=new p(g,!1)),S.updateLoadedCounts(1,x),r(S,a),k+=u,O+=n,0===s)_=[];else{let e=[],t=0;for(let n=_.length-1;n>=0;n--){const r=_[n];if(t+=r.sizeBytes,e.unshift(r),t>=s)break}_=e}}}a&&A(S)}}t&&t(e,o,F)}),!n).then((e=>{t&&t(0,"0%",M);return(n?R:I.loadFromFileData(e,o,i,a,c,d,h)).then((e=>(t&&t(100,"100%",B),e)))}))}static loadFromFileData(e,t,n,s,r,o,i){return u((()=>w.parseToUncompressedSplatArray(e))).then((e=>v.getStandardGenerator(t,n,s,r,o,i).generateFromUncompressedSplatArray(e)))}}class D{static RowSizeBytes=32;static CenterSizeBytes=12;static ScaleSizeBytes=12;static RotationSizeBytes=4;static ColorSizeBytes=4;static parseToUncompressedSplatBufferSection(e,t,n,r,o,i){const a=p.CompressionLevels[0].BytesPerCenter,l=p.CompressionLevels[0].BytesPerScale,c=p.CompressionLevels[0].BytesPerRotation,d=p.CompressionLevels[0].BytesPerSplat;for(let h=e;h<=t;h++){const e=h*D.RowSizeBytes+r,t=new Float32Array(n,e,3),u=new Float32Array(n,e+D.CenterSizeBytes,3),p=new Uint8Array(n,e+D.CenterSizeBytes+D.ScaleSizeBytes,4),m=new Uint8Array(n,e+D.CenterSizeBytes+D.ScaleSizeBytes+D.RotationSizeBytes,4),f=new s.Quaternion((m[1]-128)/128,(m[2]-128)/128,(m[3]-128)/128,(m[0]-128)/128);f.normalize();const g=h*d+i,S=new Float32Array(o,g,3),y=new Float32Array(o,g+a,3),A=new Float32Array(o,g+a+l,4),C=new Uint8Array(o,g+a+l+c,4);S[0]=t[0],S[1]=t[1],S[2]=t[2],y[0]=u[0],y[1]=u[1],y[2]=u[2],A[0]=f.w,A[1]=f.x,A[2]=f.y,A[3]=f.z,C[0]=p[0],C[1]=p[1],C[2]=p[2],C[3]=p[3]}}static parseStandardSplatToUncompressedSplatArray(e){const t=e.byteLength/D.RowSizeBytes,n=new r;for(let r=0;r<t;r++){const t=r*D.RowSizeBytes,o=new Float32Array(e,t,3),i=new Float32Array(e,t+D.CenterSizeBytes,3),a=new Uint8Array(e,t+D.CenterSizeBytes+D.ScaleSizeBytes,4),l=new Uint8Array(e,t+D.CenterSizeBytes+D.ScaleSizeBytes+D.ColorSizeBytes,4),c=new s.Quaternion((l[1]-128)/128,(l[2]-128)/128,(l[3]-128)/128,(l[0]-128)/128);c.normalize(),n.addSplatFromComonents(o[0],o[1],o[2],i[0],i[1],i[2],c.w,c.x,c.y,c.z,a[0],a[1],a[2],a[3])}return n}}class R{static loadFromURL(e,t,n,r,o,i,a,c,d,h,u){const m=p.HeaderSizeBytes+p.SectionHeaderSizeBytes,f=E.StreamingSectionSize;let g,S,y,A,C=0,x=0,b=new Promise((e=>{A=e})),w=0,T=0,v=[];return l(e,((e,o,i,a)=>{const l=e>=100;if(a||(n=!1),n){if(!g){C=a/D.RowSizeBytes,g=new ArrayBuffer(a);const e=m+p.CompressionLevels[0].BytesPerSplat*C;S=new ArrayBuffer(e),p.writeHeaderToBuffer({versionMajor:p.CurrentMajorVersion,versionMinor:p.CurrentMinorVersion,maxSectionCount:1,sectionCount:1,maxSplatCount:C,splatCount:x,compressionLevel:0,sceneCenter:new s.Vector3},S)}if(i){v.push(i),new Uint8Array(g,T,i.byteLength).set(new Uint8Array(i)),T+=i.byteLength;const e=T-w;if(e>f||l){const t=(l?e:f)/D.RowSizeBytes,n=x+t;D.parseToUncompressedSplatBufferSection(x,n-1,g,0,S,m),x=n,y||(p.writeSectionHeaderToBuffer({maxSplatCount:C,splatCount:x,bucketSize:0,bucketCount:0,bucketBlockSize:0,compressionScaleRange:0,storageSizeBytes:0,fullBucketCount:0,partiallyFilledBucketCount:0},0,S,p.HeaderSizeBytes),y=new p(S,!1)),y.updateLoadedCounts(1,x),r(y,l),w+=f}}l&&A(y)}return t&&t(e,o,F),n}),!0).then((e=>{t&&t(0,"0%",M);return(n?b:R.loadFromFileData(e,o,i,a,c,d,h,u)).then((e=>(t&&t(100,"100%",B),e)))}))}static loadFromFileData(e,t,n,r,o,i,a,l){return u((()=>{const c=D.parseStandardSplatToUncompressedSplatArray(e);if(r){return v.getStandardGenerator(t,n,o,i,a,l).generateFromUncompressedSplatArray(c)}return p.generateFromUncompressedSplatArrays([c],t,0,new s.Vector3)}))}}class k{static checkVersion(e){const t=p.CurrentMajorVersion,n=p.CurrentMinorVersion,s=p.parseHeader(e);if(s.versionMajor===t&&s.versionMinor>=n||s.versionMajor>t)return!0;throw new Error(`KSplat version not supported: v${s.versionMajor}.${s.versionMinor}. Minimum required: v${t}.${n}`)}static loadFromURL(e,t,n,s){let r,o,i,a,c,d,h=!1,u=!1,m=[],f=!1,g=!1,S=0,y=0,A=E.StreamingSectionSize,C=0,x=!1,b=[],w=new Promise((e=>{d=e}));let T=0;const v=()=>{const e=()=>{g=!0;new Blob(b).arrayBuffer().then((e=>{g=!1,f=!0,c=new ArrayBuffer(a.maxSectionCount*p.SectionHeaderSizeBytes),new Uint8Array(c).set(new Uint8Array(e,p.HeaderSizeBytes,a.maxSectionCount*p.SectionHeaderSizeBytes)),m=p.parseSectionHeaders(a,c,0,!1);let t=0;for(let e=0;e<a.maxSectionCount;e++)t+=m[e].storageSizeBytes;const n=p.HeaderSizeBytes+a.maxSectionCount*p.SectionHeaderSizeBytes+t;if(!r){r=new ArrayBuffer(n);let e=0;for(let t=0;t<b.length;t++){const n=b[t];new Uint8Array(r,e,n.byteLength).set(new Uint8Array(n)),e+=n.byteLength}}C=p.HeaderSizeBytes+p.SectionHeaderSizeBytes*a.maxSectionCount;for(let e=0;e<=m.length&&e<a.maxSectionCount;e++)C+=m[e].storageSizeBytes;0===T&&(T++,window.setTimeout((()=>{T--,P(!0)}),1))}))};!g&&!f&&h&&S>=p.HeaderSizeBytes+p.SectionHeaderSizeBytes*a.maxSectionCount&&e()},P=()=>{if(f){if(x)return;x=S>=C;if(S-y>A||x){y=S,o||(o=new p(r,!1));const e=p.HeaderSizeBytes+p.SectionHeaderSizeBytes*a.maxSectionCount;let t=0,n=0,i=0;for(let s=0;s<a.maxSectionCount;s++){const r=m[s],l=e+(t+4*r.partiallyFilledBucketCount+r.bucketStorageSizeBytes*r.bucketCount);if(!(S>=l))break;{n++;const e=S-l,t=p.CompressionLevels[a.compressionLevel].BytesPerSplat;let c=Math.floor(e/t);c=Math.min(c,r.maxSplatCount),i+=c,o.updateLoadedCounts(n,i),o.updateSectionLoadedCounts(s,c)}t+=r.storageSizeBytes}s(o,x),x&&d(o)}}};return l(e,((e,s,o)=>{o&&(b.push(o),r&&new Uint8Array(r,S,o.byteLength).set(new Uint8Array(o)),S+=o.byteLength),n&&(!h&&!u&&S>=p.HeaderSizeBytes&&(u=!0,new Blob(b).arrayBuffer().then((e=>{i=new ArrayBuffer(p.HeaderSizeBytes),new Uint8Array(i).set(new Uint8Array(e,0,p.HeaderSizeBytes)),k.checkVersion(i),u=!1,h=!0,a=p.parseHeader(i),window.setTimeout((()=>{v()}),1)}))),v(),P()),t&&t(e,s,F)}),!n).then((e=>{t&&t(0,"0%",M);return(n?w:k.loadFromFileData(e)).then((e=>(t&&t(100,"100%",B),e)))}))}static loadFromFileData(e){return u((()=>(k.checkVersion(e),new p(e))))}static downloadFile=function(){let e;return function(t,n){const s=new Blob([t.bufferData],{type:"application/octet-stream"});e||(e=document.createElement("a"),document.body.appendChild(e)),e.download=n,e.href=URL.createObjectURL(s),e.click()}}()}const O={Splat:0,KSplat:1,Ply:2},L=e=>e.endsWith(".ply")?O.Ply:e.endsWith(".splat")?O.Splat:e.endsWith(".ksplat")?O.KSplat:null;var z=Object.freeze({__proto__:null,sceneFormatFromPath:L});const U={type:"change"},_={type:"start"},V={type:"end"},N=new t.Ray,H=new t.Plane,j=Math.cos(70*t.MathUtils.DEG2RAD);class W extends t.EventDispatcher{constructor(e,n){super(),this.object=e,this.domElement=n,this.domElement.style.touchAction="none",this.enabled=!0,this.target=new t.Vector3,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.zoomToCursor=!1,this.autoRotate=!1,this.autoRotateSpeed=2,this.keys={LEFT:"KeyA",UP:"KeyW",RIGHT:"KeyD",BOTTOM:"KeyS"},this.mouseButtons={LEFT:t.MOUSE.ROTATE,MIDDLE:t.MOUSE.DOLLY,RIGHT:t.MOUSE.PAN},this.touches={ONE:t.TOUCH.ROTATE,TWO:t.TOUCH.DOLLY_PAN},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this._domElementKeyEvents=null,this.getPolarAngle=function(){return a.phi},this.getAzimuthalAngle=function(){return a.theta},this.getDistance=function(){return this.object.position.distanceTo(this.target)},this.listenToKeyEvents=function(e){e.addEventListener("keydown",J),this._domElementKeyEvents=e},this.stopListenToKeyEvents=function(){this._domElementKeyEvents.removeEventListener("keydown",J),this._domElementKeyEvents=null},this.saveState=function(){s.target0.copy(s.target),s.position0.copy(s.object.position),s.zoom0=s.object.zoom},this.reset=function(){s.target.copy(s.target0),s.object.position.copy(s.position0),s.object.zoom=s.zoom0,s.object.updateProjectionMatrix(),s.dispatchEvent(U),s.update(),o=r.NONE},this.update=function(){const n=new t.Vector3,h=(new t.Quaternion).setFromUnitVectors(e.up,new t.Vector3(0,1,0)),u=h.clone().invert(),p=new t.Vector3,m=new t.Quaternion,f=new t.Vector3,g=2*Math.PI;return function(){h.setFromUnitVectors(e.up,new t.Vector3(0,1,0)),u.copy(h).invert();const S=s.object.position;n.copy(S).sub(s.target),n.applyQuaternion(h),a.setFromVector3(n),s.autoRotate&&o===r.NONE&&F(2*Math.PI/60/60*s.autoRotateSpeed),s.enableDamping?(a.theta+=l.theta*s.dampingFactor,a.phi+=l.phi*s.dampingFactor):(a.theta+=l.theta,a.phi+=l.phi);let y=s.minAzimuthAngle,A=s.maxAzimuthAngle;isFinite(y)&&isFinite(A)&&(y<-Math.PI?y+=g:y>Math.PI&&(y-=g),A<-Math.PI?A+=g:A>Math.PI&&(A-=g),a.theta=y<=A?Math.max(y,Math.min(A,a.theta)):a.theta>(y+A)/2?Math.max(y,a.theta):Math.min(A,a.theta)),a.phi=Math.max(s.minPolarAngle,Math.min(s.maxPolarAngle,a.phi)),a.makeSafe(),!0===s.enableDamping?s.target.addScaledVector(d,s.dampingFactor):s.target.add(d),s.zoomToCursor&&b||s.object.isOrthographicCamera?a.radius=k(a.radius):a.radius=k(a.radius*c),n.setFromSpherical(a),n.applyQuaternion(u),S.copy(s.target).add(n),s.object.lookAt(s.target),!0===s.enableDamping?(l.theta*=1-s.dampingFactor,l.phi*=1-s.dampingFactor,d.multiplyScalar(1-s.dampingFactor)):(l.set(0,0,0),d.set(0,0,0));let w=!1;if(s.zoomToCursor&&b){let r=null;if(s.object.isPerspectiveCamera){const e=n.length();r=k(e*c);const t=e-r;s.object.position.addScaledVector(C,t),s.object.updateMatrixWorld()}else if(s.object.isOrthographicCamera){const e=new t.Vector3(x.x,x.y,0);e.unproject(s.object),s.object.zoom=Math.max(s.minZoom,Math.min(s.maxZoom,s.object.zoom/c)),s.object.updateProjectionMatrix(),w=!0;const o=new t.Vector3(x.x,x.y,0);o.unproject(s.object),s.object.position.sub(o).add(e),s.object.updateMatrixWorld(),r=n.length()}else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."),s.zoomToCursor=!1;null!==r&&(this.screenSpacePanning?s.target.set(0,0,-1).transformDirection(s.object.matrix).multiplyScalar(r).add(s.object.position):(N.origin.copy(s.object.position),N.direction.set(0,0,-1).transformDirection(s.object.matrix),Math.abs(s.object.up.dot(N.direction))<j?e.lookAt(s.target):(H.setFromNormalAndCoplanarPoint(s.object.up,s.target),N.intersectPlane(H,s.target))))}else s.object.isOrthographicCamera&&(s.object.zoom=Math.max(s.minZoom,Math.min(s.maxZoom,s.object.zoom/c)),s.object.updateProjectionMatrix(),w=!0);return c=1,b=!1,!!(w||p.distanceToSquared(s.object.position)>i||8*(1-m.dot(s.object.quaternion))>i||f.distanceToSquared(s.target)>0)&&(s.dispatchEvent(U),p.copy(s.object.position),m.copy(s.object.quaternion),f.copy(s.target),w=!1,!0)}}(),this.dispose=function(){s.domElement.removeEventListener("contextmenu",ee),s.domElement.removeEventListener("pointerdown",K),s.domElement.removeEventListener("pointercancel",$),s.domElement.removeEventListener("wheel",Z),s.domElement.removeEventListener("pointermove",q),s.domElement.removeEventListener("pointerup",$),null!==s._domElementKeyEvents&&(s._domElementKeyEvents.removeEventListener("keydown",J),s._domElementKeyEvents=null)};const s=this,r={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6};let o=r.NONE;const i=1e-6,a=new t.Spherical,l=new t.Spherical;let c=1;const d=new t.Vector3,h=new t.Vector2,u=new t.Vector2,p=new t.Vector2,m=new t.Vector2,f=new t.Vector2,g=new t.Vector2,S=new t.Vector2,y=new t.Vector2,A=new t.Vector2,C=new t.Vector3,x=new t.Vector2;let b=!1;const w=[],T={};function v(){return Math.pow(.95,s.zoomSpeed)}function F(e){l.theta-=e}function M(e){l.phi-=e}const B=function(){const e=new t.Vector3;return function(t,n){e.setFromMatrixColumn(n,0),e.multiplyScalar(-t),d.add(e)}}(),E=function(){const e=new t.Vector3;return function(t,n){!0===s.screenSpacePanning?e.setFromMatrixColumn(n,1):(e.setFromMatrixColumn(n,0),e.crossVectors(s.object.up,e)),e.multiplyScalar(t),d.add(e)}}(),P=function(){const e=new t.Vector3;return function(t,n){const r=s.domElement;if(s.object.isPerspectiveCamera){const o=s.object.position;e.copy(o).sub(s.target);let i=e.length();i*=Math.tan(s.object.fov/2*Math.PI/180),B(2*t*i/r.clientHeight,s.object.matrix),E(2*n*i/r.clientHeight,s.object.matrix)}else s.object.isOrthographicCamera?(B(t*(s.object.right-s.object.left)/s.object.zoom/r.clientWidth,s.object.matrix),E(n*(s.object.top-s.object.bottom)/s.object.zoom/r.clientHeight,s.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),s.enablePan=!1)}}();function I(e){s.object.isPerspectiveCamera||s.object.isOrthographicCamera?c/=e:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),s.enableZoom=!1)}function D(e){s.object.isPerspectiveCamera||s.object.isOrthographicCamera?c*=e:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),s.enableZoom=!1)}function R(t){if(!s.zoomToCursor)return;b=!0;const n=s.domElement.getBoundingClientRect(),r=t.clientX-n.left,o=t.clientY-n.top,i=n.width,a=n.height;x.x=r/i*2-1,x.y=-o/a*2+1,C.set(x.x,x.y,1).unproject(e).sub(e.position).normalize()}function k(e){return Math.max(s.minDistance,Math.min(s.maxDistance,e))}function O(e){h.set(e.clientX,e.clientY)}function L(e){m.set(e.clientX,e.clientY)}function z(){if(1===w.length)h.set(w[0].pageX,w[0].pageY);else{const e=.5*(w[0].pageX+w[1].pageX),t=.5*(w[0].pageY+w[1].pageY);h.set(e,t)}}function W(){if(1===w.length)m.set(w[0].pageX,w[0].pageY);else{const e=.5*(w[0].pageX+w[1].pageX),t=.5*(w[0].pageY+w[1].pageY);m.set(e,t)}}function G(){const e=w[0].pageX-w[1].pageX,t=w[0].pageY-w[1].pageY,n=Math.sqrt(e*e+t*t);S.set(0,n)}function Q(e){if(1==w.length)u.set(e.pageX,e.pageY);else{const t=ne(e),n=.5*(e.pageX+t.x),s=.5*(e.pageY+t.y);u.set(n,s)}p.subVectors(u,h).multiplyScalar(s.rotateSpeed);const t=s.domElement;F(2*Math.PI*p.x/t.clientHeight),M(2*Math.PI*p.y/t.clientHeight),h.copy(u)}function Y(e){if(1===w.length)f.set(e.pageX,e.pageY);else{const t=ne(e),n=.5*(e.pageX+t.x),s=.5*(e.pageY+t.y);f.set(n,s)}g.subVectors(f,m).multiplyScalar(s.panSpeed),P(g.x,g.y),m.copy(f)}function X(e){const t=ne(e),n=e.pageX-t.x,r=e.pageY-t.y,o=Math.sqrt(n*n+r*r);y.set(0,o),A.set(0,Math.pow(y.y/S.y,s.zoomSpeed)),I(A.y),S.copy(y)}function K(e){!1!==s.enabled&&(0===w.length&&(s.domElement.setPointerCapture(e.pointerId),s.domElement.addEventListener("pointermove",q),s.domElement.addEventListener("pointerup",$)),function(e){w.push(e)}(e),"touch"===e.pointerType?function(e){switch(te(e),w.length){case 1:switch(s.touches.ONE){case t.TOUCH.ROTATE:if(!1===s.enableRotate)return;z(),o=r.TOUCH_ROTATE;break;case t.TOUCH.PAN:if(!1===s.enablePan)return;W(),o=r.TOUCH_PAN;break;default:o=r.NONE}break;case 2:switch(s.touches.TWO){case t.TOUCH.DOLLY_PAN:if(!1===s.enableZoom&&!1===s.enablePan)return;s.enableZoom&&G(),s.enablePan&&W(),o=r.TOUCH_DOLLY_PAN;break;case t.TOUCH.DOLLY_ROTATE:if(!1===s.enableZoom&&!1===s.enableRotate)return;s.enableZoom&&G(),s.enableRotate&&z(),o=r.TOUCH_DOLLY_ROTATE;break;default:o=r.NONE}break;default:o=r.NONE}o!==r.NONE&&s.dispatchEvent(_)}(e):function(e){let n;switch(e.button){case 0:n=s.mouseButtons.LEFT;break;case 1:n=s.mouseButtons.MIDDLE;break;case 2:n=s.mouseButtons.RIGHT;break;default:n=-1}switch(n){case t.MOUSE.DOLLY:if(!1===s.enableZoom)return;!function(e){R(e),S.set(e.clientX,e.clientY)}(e),o=r.DOLLY;break;case t.MOUSE.ROTATE:if(e.ctrlKey||e.metaKey||e.shiftKey){if(!1===s.enablePan)return;L(e),o=r.PAN}else{if(!1===s.enableRotate)return;O(e),o=r.ROTATE}break;case t.MOUSE.PAN:if(e.ctrlKey||e.metaKey||e.shiftKey){if(!1===s.enableRotate)return;O(e),o=r.ROTATE}else{if(!1===s.enablePan)return;L(e),o=r.PAN}break;default:o=r.NONE}o!==r.NONE&&s.dispatchEvent(_)}(e))}function q(e){!1!==s.enabled&&("touch"===e.pointerType?function(e){switch(te(e),o){case r.TOUCH_ROTATE:if(!1===s.enableRotate)return;Q(e),s.update();break;case r.TOUCH_PAN:if(!1===s.enablePan)return;Y(e),s.update();break;case r.TOUCH_DOLLY_PAN:if(!1===s.enableZoom&&!1===s.enablePan)return;!function(e){s.enableZoom&&X(e),s.enablePan&&Y(e)}(e),s.update();break;case r.TOUCH_DOLLY_ROTATE:if(!1===s.enableZoom&&!1===s.enableRotate)return;!function(e){s.enableZoom&&X(e),s.enableRotate&&Q(e)}(e),s.update();break;default:o=r.NONE}}(e):function(e){switch(o){case r.ROTATE:if(!1===s.enableRotate)return;!function(e){u.set(e.clientX,e.clientY),p.subVectors(u,h).multiplyScalar(s.rotateSpeed);const t=s.domElement;F(2*Math.PI*p.x/t.clientHeight),M(2*Math.PI*p.y/t.clientHeight),h.copy(u),s.update()}(e);break;case r.DOLLY:if(!1===s.enableZoom)return;!function(e){y.set(e.clientX,e.clientY),A.subVectors(y,S),A.y>0?I(v()):A.y<0&&D(v()),S.copy(y),s.update()}(e);break;case r.PAN:if(!1===s.enablePan)return;!function(e){f.set(e.clientX,e.clientY),g.subVectors(f,m).multiplyScalar(s.panSpeed),P(g.x,g.y),m.copy(f),s.update()}(e)}}(e))}function $(e){!function(e){delete T[e.pointerId];for(let t=0;t<w.length;t++)if(w[t].pointerId==e.pointerId)return void w.splice(t,1)}(e),0===w.length&&(s.domElement.releasePointerCapture(e.pointerId),s.domElement.removeEventListener("pointermove",q),s.domElement.removeEventListener("pointerup",$)),s.dispatchEvent(V),o=r.NONE}function Z(e){!1!==s.enabled&&!1!==s.enableZoom&&o===r.NONE&&(e.preventDefault(),s.dispatchEvent(_),function(e){R(e),e.deltaY<0?D(v()):e.deltaY>0&&I(v()),s.update()}(e),s.dispatchEvent(V))}function J(e){!1!==s.enabled&&!1!==s.enablePan&&function(e){let t=!1;switch(e.code){case s.keys.UP:e.ctrlKey||e.metaKey||e.shiftKey?M(2*Math.PI*s.rotateSpeed/s.domElement.clientHeight):P(0,s.keyPanSpeed),t=!0;break;case s.keys.BOTTOM:e.ctrlKey||e.metaKey||e.shiftKey?M(-2*Math.PI*s.rotateSpeed/s.domElement.clientHeight):P(0,-s.keyPanSpeed),t=!0;break;case s.keys.LEFT:e.ctrlKey||e.metaKey||e.shiftKey?F(2*Math.PI*s.rotateSpeed/s.domElement.clientHeight):P(s.keyPanSpeed,0),t=!0;break;case s.keys.RIGHT:e.ctrlKey||e.metaKey||e.shiftKey?F(-2*Math.PI*s.rotateSpeed/s.domElement.clientHeight):P(-s.keyPanSpeed,0),t=!0}t&&(e.preventDefault(),s.update())}(e)}function ee(e){!1!==s.enabled&&e.preventDefault()}function te(e){let n=T[e.pointerId];void 0===n&&(n=new t.Vector2,T[e.pointerId]=n),n.set(e.pageX,e.pageY)}function ne(e){const t=e.pointerId===w[0].pointerId?w[1]:w[0];return T[t.pointerId]}s.domElement.addEventListener("contextmenu",ee),s.domElement.addEventListener("pointerdown",K),s.domElement.addEventListener("pointercancel",$),s.domElement.addEventListener("wheel",Z,{passive:!1}),this.update()}}class G{static elementIDGen=0;constructor(e,t){this.taskIDGen=0,this.elementID=G.elementIDGen++,this.tasks=[],this.message=e||"Loading...",this.container=t||document.body,this.spinnerContainerOuter=document.createElement("div"),this.spinnerContainerOuter.className=`spinnerOuterContainer${this.elementID}`,this.spinnerContainerOuter.style.display="none",this.spinnerContainerPrimary=document.createElement("div"),this.spinnerContainerPrimary.className=`spinnerContainerPrimary${this.elementID}`,this.spinnerPrimary=document.createElement("div"),this.spinnerPrimary.classList.add(`spinner${this.elementID}`,`spinnerPrimary${this.elementID}`),this.messageContainerPrimary=document.createElement("div"),this.messageContainerPrimary.classList.add(`messageContainer${this.elementID}`,`messageContainerPrimary${this.elementID}`),this.messageContainerPrimary.innerHTML=this.message,this.spinnerContainerMin=document.createElement("div"),this.spinnerContainerMin.className=`spinnerContainerMin${this.elementID}`,this.spinnerMin=document.createElement("div"),this.spinnerMin.classList.add(`spinner${this.elementID}`,`spinnerMin${this.elementID}`),this.messageContainerMin=document.createElement("div"),this.messageContainerMin.classList.add(`messageContainer${this.elementID}`,`messageContainerMin${this.elementID}`),this.messageContainerMin.innerHTML=this.message,this.spinnerContainerPrimary.appendChild(this.spinnerPrimary),this.spinnerContainerPrimary.appendChild(this.messageContainerPrimary),this.spinnerContainerOuter.appendChild(this.spinnerContainerPrimary),this.spinnerContainerMin.appendChild(this.spinnerMin),this.spinnerContainerMin.appendChild(this.messageContainerMin),this.spinnerContainerOuter.appendChild(this.spinnerContainerMin);const n=document.createElement("style");n.innerHTML=`\n\n            .spinnerOuterContainer${this.elementID} {\n                width: 100%;\n                height: 100%;\n                margin: 0;\n                top: 0;\n                left: 0;\n                position: absolute;\n                pointer-events: none;\n            }\n\n            .messageContainer${this.elementID} {\n                height: 20px;\n                font-family: arial;\n                font-size: 12pt;\n                color: #ffffff;\n                text-align: center;\n                vertical-align: middle;\n            }\n\n            .spinner${this.elementID} {\n                padding: 15px;\n                background: #07e8d6;\n                z-index:99999;\n            \n                aspect-ratio: 1;\n                border-radius: 50%;\n                --_m: \n                    conic-gradient(#0000,#000),\n                    linear-gradient(#000 0 0) content-box;\n                -webkit-mask: var(--_m);\n                    mask: var(--_m);\n                -webkit-mask-composite: source-out;\n                    mask-composite: subtract;\n                box-sizing: border-box;\n                animation: load 1s linear infinite;\n            }\n\n            .spinnerContainerPrimary${this.elementID} {\n                z-index:99999;\n                background-color: rgba(128, 128, 128, 0.75);\n                border: #666666 1px solid;\n                border-radius: 5px;\n                padding-top: 20px;\n                padding-bottom: 10px;\n                margin: 0;\n                position: absolute;\n                top: 50%;\n                left: 50%;\n                transform: translate(-80px, -80px);\n                width: 180px;\n                pointer-events: auto;\n            }\n\n            .spinnerPrimary${this.elementID} {\n                width: 120px;\n                margin-left: 30px;\n            }\n\n            .messageContainerPrimary${this.elementID} {\n                padding-top: 15px;\n            }\n\n            .spinnerContainerMin${this.elementID} {\n                z-index:99999;\n                background-color: rgba(128, 128, 128, 0.75);\n                border: #666666 1px solid;\n                border-radius: 5px;\n                padding-top: 20px;\n                padding-bottom: 15px;\n                margin: 0;\n                position: absolute;\n                bottom: 50px;\n                left: 50%;\n                transform: translate(-50%, 0);\n                display: flex;\n                flex-direction: left;\n                pointer-events: auto;\n                min-width: 250px;\n            }\n\n            .messageContainerMin${this.elementID} {\n                margin-right: 15px;\n            }\n\n            .spinnerMin${this.elementID} {\n                width: 50px;\n                height: 50px;\n                margin-left: 15px;\n                margin-right: 25px;\n            }\n\n            .messageContainerMin${this.elementID} {\n                padding-top: 15px;\n            }\n            \n            @keyframes load {\n                to{transform: rotate(1turn)}\n            }\n\n        `,this.spinnerContainerOuter.appendChild(n),this.container.appendChild(this.spinnerContainerOuter),this.setMinimized(!1,!0),this.fadeTransitions=[]}addTask(e){const t={message:e,id:this.taskIDGen++};return this.tasks.push(t),this.update(),t.id}removeTask(e){let t=0;for(let n of this.tasks){if(n.id===e){this.tasks.splice(t,1);break}t++}this.update()}removeAllTasks(){this.tasks=[],this.update()}setMessageForTask(e,t){for(let n of this.tasks)if(n.id===e){n.message=t;break}this.update()}update(){this.tasks.length>0?(this.show(),this.setMessage(this.tasks[this.tasks.length-1].message)):this.hide()}show(){this.spinnerContainerOuter.style.display="block",this.visible=!0}hide(){this.spinnerContainerOuter.style.display="none",this.visible=!1}setContainer(e){this.container&&this.container.removeChild(this.spinnerContainerOuter),e&&(this.container=e,this.container.appendChild(this.spinnerContainerOuter),this.spinnerContainerOuter.style.zIndex=this.container.style.zIndex+1)}setMinimized(e,t){const n=(e,t,n,s,r)=>{n?e.style.display=t?s:"none":this.fadeTransitions[r]=((e,t,n,s,r)=>{const o=performance.now();let i="none"===e.style.display?0:parseFloat(e.style.opacity);isNaN(i)&&(i=1);const a=window.setInterval((()=>{const l=performance.now()-o;let c,d=Math.min(l/s,1);d>.999&&(d=1),t?(c=(1-d)*i,c<1e-4&&(c=0)):c=(1-i)*d+i,c>0?(e.style.display=n,e.style.opacity=c):e.style.display="none",d>=1&&(r&&r(),window.clearInterval(a))}),16);return a})(e,!t,s,500,(()=>{this.fadeTransitions[r]=null}))};n(this.spinnerContainerPrimary,!e,t,"block",0),n(this.spinnerContainerMin,e,t,"flex",1),this.minimized=e}setMessage(e){this.messageContainerPrimary.innerHTML=e,this.messageContainerMin.innerHTML=e}}class Q{constructor(e){this.idGen=0,this.tasks=[],this.container=e||document.body,this.progressBarContainerOuter=document.createElement("div"),this.progressBarContainerOuter.className="progressBarOuterContainer",this.progressBarContainerOuter.style.display="none",this.progressBarBox=document.createElement("div"),this.progressBarBox.className="progressBarBox",this.progressBarBackground=document.createElement("div"),this.progressBarBackground.className="progressBarBackground",this.progressBar=document.createElement("div"),this.progressBar.className="progressBar",this.progressBarBackground.appendChild(this.progressBar),this.progressBarBox.appendChild(this.progressBarBackground),this.progressBarContainerOuter.appendChild(this.progressBarBox);const t=document.createElement("style");t.innerHTML="\n\n            .progressBarOuterContainer {\n                width: 100%;\n                height: 100%;\n                margin: 0;\n                top: 0;\n                left: 0;\n                position: absolute;\n                pointer-events: none;\n            }\n\n            .progressBarBox {\n                z-index:99999;\n                padding: 7px 9px 5px 7px;\n                background-color: rgba(190, 190, 190, 0.75);\n                border: #555555 1px solid;\n                border-radius: 15px;\n                margin: 0;\n                position: absolute;\n                bottom: 50px;\n                left: 50%;\n                transform: translate(-50%, 0);\n                width: 180px;\n                height: 30px;\n                pointer-events: auto;\n            }\n\n            .progressBarBackground {\n                width: 100%;\n                height: 25px;\n                border-radius:10px;\n                background-color: rgba(128, 128, 128, 0.75);\n                border: #444444 1px solid;\n                box-shadow: inset 0 0 10px #333333;\n            }\n\n            .progressBar {\n                height: 25px;\n                width: 0px;\n                border-radius:10px;\n                background-color: rgba(0, 200, 0, 0.75);\n                box-shadow: inset 0 0 10px #003300;\n            }\n\n        ",this.progressBarContainerOuter.appendChild(t),this.container.appendChild(this.progressBarContainerOuter)}show(){this.progressBarContainerOuter.style.display="block"}hide(){this.progressBarContainerOuter.style.display="none"}setProgress(e){this.progressBar.style.width=e+"%"}setContainer(e){this.container&&this.container.removeChild(this.progressBarContainerOuter),e&&(this.container=e,this.container.appendChild(this.progressBarContainerOuter),this.progressBarContainerOuter.style.zIndex=this.container.style.zIndex+1)}}class Y{constructor(e){this.container=e||document.body,this.infoCells={};const t=[["Camera position","cameraPosition"],["Camera look-at","cameraLookAt"],["Camera up","cameraUp"],["Cursor position","cursorPosition"],["FPS","fps"],["Rendering:","renderSplatCount"],["Sort time","sortTime"],["Render window","renderWindow"],["Focal adjustment","focalAdjustment"]];this.infoPanelContainer=document.createElement("div");const n=document.createElement("style");n.innerHTML="\n\n            .infoPanel {\n                width: 430px;\n                padding: 10px;\n                background-color: rgba(50, 50, 50, 0.85);\n                border: #555555 2px solid;\n                color: #dddddd;\n                border-radius: 10px;\n                z-index: 9999;\n                font-family: arial;\n                font-size: 11pt;\n                text-align: left;\n                margin: 0;\n                top: 10px;\n                left:10px;\n                position: absolute;\n                pointer-events: auto;\n            }\n\n            .info-panel-cell {\n                margin-bottom: 5px;\n                padding-bottom: 2px;\n            }\n\n            .label-cell {\n                font-weight: bold;\n                font-size: 12pt;\n                width: 140px;\n            }\n\n        ",this.infoPanelContainer.append(n),this.infoPanel=document.createElement("div"),this.infoPanel.className="infoPanel";const s=document.createElement("div");s.style.display="table";for(let e of t){const t=document.createElement("div");t.style.display="table-row",t.className="info-panel-row";const n=document.createElement("div");n.style.display="table-cell",n.innerHTML=`${e[0]}: `,n.classList.add("info-panel-cell","label-cell");const r=document.createElement("div");r.style.display="table-cell",r.style.width="10px",r.innerHTML=" ",r.className="info-panel-cell";const o=document.createElement("div");o.style.display="table-cell",o.innerHTML="",o.className="info-panel-cell",this.infoCells[e[1]]=o,t.appendChild(n),t.appendChild(r),t.appendChild(o),s.appendChild(t)}this.infoPanel.appendChild(s),this.infoPanelContainer.append(this.infoPanel),this.infoPanelContainer.style.display="none",this.container.appendChild(this.infoPanelContainer),this.visible=!1}update=function(e,t,n,s,r,o,i,a,l,c,d){const h=`${t.x.toFixed(5)}, ${t.y.toFixed(5)}, ${t.z.toFixed(5)}`;if(this.infoCells.cameraPosition.innerHTML!==h&&(this.infoCells.cameraPosition.innerHTML=h),n){const e=n,t=`${e.x.toFixed(5)}, ${e.y.toFixed(5)}, ${e.z.toFixed(5)}`;this.infoCells.cameraLookAt.innerHTML!==t&&(this.infoCells.cameraLookAt.innerHTML=t)}const u=`${s.x.toFixed(5)}, ${s.y.toFixed(5)}, ${s.z.toFixed(5)}`;if(this.infoCells.cameraUp.innerHTML!==u&&(this.infoCells.cameraUp.innerHTML=u),r){const e=r,t=`${e.x.toFixed(5)}, ${e.y.toFixed(5)}, ${e.z.toFixed(5)}`;this.infoCells.cursorPosition.innerHTML=t}else this.infoCells.cursorPosition.innerHTML="N/A";this.infoCells.fps.innerHTML=o,this.infoCells.renderWindow.innerHTML=`${e.x} x ${e.y}`,this.infoCells.renderSplatCount.innerHTML=`${a} splats out of ${i} (${l.toFixed(2)}%)`,this.infoCells.sortTime.innerHTML=`${c.toFixed(3)} ms`,this.infoCells.focalAdjustment.innerHTML=`${d.toFixed(3)}`};setContainer(e){this.container&&this.container.removeChild(this.infoPanelContainer),e&&(this.container=e,this.container.appendChild(this.infoPanelContainer),this.infoPanelContainer.style.zIndex=this.container.style.zIndex+1)}show(){this.infoPanelContainer.style.display="block",this.visible=!0}hide(){this.infoPanelContainer.style.display="none",this.visible=!1}}class X extends s.Object3D{constructor(e=new s.Vector3(0,0,1),t=new s.Vector3(0,0,0),n=1,r=.1,o=16776960,i=.2*n,a=.2*i){super(),this.type="ArrowHelper";const l=new s.CylinderGeometry(r,r,n,32);l.translate(0,n/2,0);const c=new s.CylinderGeometry(0,a,i,32);c.translate(0,n,0),this.position.copy(t),this.line=new s.Mesh(l,new s.MeshBasicMaterial({color:o,toneMapped:!1})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new s.Mesh(c,new s.MeshBasicMaterial({color:o,toneMapped:!1})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(e)}setDirection(e){if(e.y>.99999)this.quaternion.set(0,0,0,1);else if(e.y<-.99999)this.quaternion.set(1,0,0,0);else{_axis.set(e.z,0,-e.x).normalize();const t=Math.acos(e.y);this.quaternion.setFromAxisAngle(_axis,t)}}setColor(e){this.line.material.color.set(e),this.cone.material.color.set(e)}copy(e){return super.copy(e,!1),this.line.copy(e.line),this.cone.copy(e.cone),this}dispose(){this.line.geometry.dispose(),this.line.material.dispose(),this.cone.geometry.dispose(),this.cone.material.dispose()}}class K{constructor(e){this.threeScene=e,this.splatRenderTarget=null,this.renderTargetCopyQuad=null,this.renderTargetCopyCamera=null,this.meshCursor=null,this.focusMarker=null,this.controlPlane=null,this.debugRoot=null,this.secondaryDebugRoot=null}updateSplatRenderTargetForRenderDimensions(e,t){this.destroySplatRendertarget(),this.splatRenderTarget=new s.WebGLRenderTarget(e,t,{format:s.RGBAFormat,stencilBuffer:!1,depthBuffer:!0}),this.splatRenderTarget.depthTexture=new s.DepthTexture(e,t),this.splatRenderTarget.depthTexture.format=s.DepthFormat,this.splatRenderTarget.depthTexture.type=s.UnsignedIntType}destroySplatRendertarget(){this.splatRenderTarget&&(this.splatRenderTarget=null)}setupRenderTargetCopyObjects(){const e=new s.ShaderMaterial({vertexShader:"\n                varying vec2 vUv;\n                void main() {\n                    vUv = uv;\n                    gl_Position = vec4( position.xy, 0.0, 1.0 );    \n                }\n            ",fragmentShader:"\n                #include <common>\n                #include <packing>\n                varying vec2 vUv;\n                uniform sampler2D sourceColorTexture;\n                uniform sampler2D sourceDepthTexture;\n                void main() {\n                    vec4 color = texture2D(sourceColorTexture, vUv);\n                    float fragDepth = texture2D(sourceDepthTexture, vUv).x;\n                    gl_FragDepth = fragDepth;\n                    gl_FragColor = vec4(color.rgb, color.a * 2.0);\n              }\n            ",uniforms:{sourceColorTexture:{type:"t",value:null},sourceDepthTexture:{type:"t",value:null}},depthWrite:!1,depthTest:!1,transparent:!0,blending:s.CustomBlending,blendSrc:s.SrcAlphaFactor,blendSrcAlpha:s.SrcAlphaFactor,blendDst:s.OneMinusSrcAlphaFactor,blendDstAlpha:s.OneMinusSrcAlphaFactor});e.extensions.fragDepth=!0,this.renderTargetCopyQuad=new s.Mesh(new s.PlaneGeometry(2,2),e),this.renderTargetCopyCamera=new s.OrthographicCamera(-1,1,1,-1,0,1)}destroyRenderTargetCopyObjects(){this.renderTargetCopyQuad&&(h(this.renderTargetCopyQuad),this.renderTargetCopyQuad=null)}setupMeshCursor(){if(!this.meshCursor){const e=new s.ConeGeometry(.5,1.5,32),t=new s.MeshBasicMaterial({color:16777215}),n=new s.Mesh(e,t);n.rotation.set(0,0,Math.PI),n.position.set(0,1,0);const r=new s.Mesh(e,t);r.position.set(0,-1,0);const o=new s.Mesh(e,t);o.rotation.set(0,0,Math.PI/2),o.position.set(1,0,0);const i=new s.Mesh(e,t);i.rotation.set(0,0,-Math.PI/2),i.position.set(-1,0,0),this.meshCursor=new s.Object3D,this.meshCursor.add(n),this.meshCursor.add(r),this.meshCursor.add(o),this.meshCursor.add(i),this.meshCursor.scale.set(.1,.1,.1),this.threeScene.add(this.meshCursor),this.meshCursor.visible=!1}}destroyMeshCursor(){this.meshCursor&&(h(this.meshCursor),this.threeScene.remove(this.meshCursor),this.meshCursor=null)}setMeshCursorVisibility(e){this.meshCursor.visible=e}getMeschCursorVisibility(){return this.meshCursor.visible}setMeshCursorPosition(e){this.meshCursor.position.copy(e)}positionAndOrientMeshCursor(e,t){this.meshCursor.position.copy(e),this.meshCursor.up.copy(t.up),this.meshCursor.lookAt(t.position)}setupFocusMarker(){if(!this.focusMarker){const e=new s.SphereGeometry(.5,32,32),t=K.buildFocusMarkerMaterial();t.depthTest=!1,t.depthWrite=!1,t.transparent=!0,this.focusMarker=new s.Mesh(e,t)}}destroyFocusMarker(){this.focusMarker&&(h(this.focusMarker),this.focusMarker=null)}updateFocusMarker=function(){const e=new s.Vector3,t=new s.Matrix4;return function(n,s,r){t.copy(s.matrixWorld).invert(),e.copy(n).applyMatrix4(t),e.normalize().multiplyScalar(10),e.applyMatrix4(s.matrixWorld),this.focusMarker.position.copy(e),this.focusMarker.material.uniforms.realFocusPosition.value.copy(n),this.focusMarker.material.uniforms.viewport.value.copy(r),this.focusMarker.material.uniformsNeedUpdate=!0}}();setFocusMarkerVisibility(e){this.focusMarker.visible=e}setFocusMarkerOpacity(e){this.focusMarker.material.uniforms.opacity.value=e,this.focusMarker.material.uniformsNeedUpdate=!0}getFocusMarkerOpacity(){return this.focusMarker.material.uniforms.opacity.value}setupControlPlane(){if(!this.controlPlane){const e=new s.PlaneGeometry(1,1);e.rotateX(-Math.PI/2);const t=new s.MeshBasicMaterial({color:16777215});t.transparent=!0,t.opacity=.6,t.depthTest=!1,t.depthWrite=!1,t.side=s.DoubleSide;const n=new s.Mesh(e,t),r=new s.Vector3(0,1,0);r.normalize();const o=new s.Vector3(0,0,0),i=new X(r,o,.5,.01,56576,.1,.03);this.controlPlane=new s.Object3D,this.controlPlane.add(n),this.controlPlane.add(i)}}destroyControlPlane(){this.controlPlane&&(h(this.controlPlane),this.controlPlane=null)}setControlPlaneVisibility(e){this.controlPlane.visible=e}positionAndOrientControlPlane=function(){const e=new s.Quaternion,t=new s.Vector3(0,1,0);return function(n,s){e.setFromUnitVectors(t,s),this.controlPlane.position.copy(n),this.controlPlane.quaternion.copy(e)}}();addDebugMeshes(){this.debugRoot=this.createDebugMeshes(),this.secondaryDebugRoot=this.createSecondaryDebugMeshes(),this.threeScene.add(this.debugRoot),this.threeScene.add(this.secondaryDebugRoot)}destroyDebugMeshes(){for(let e of[this.debugRoot,this.secondaryDebugRoot])e&&(h(e),this.threeScene.remove(e));this.debugRoot=null,this.secondaryDebugRoot=null}createDebugMeshes(e){const t=new s.SphereGeometry(1,32,32),n=new s.Object3D,r=(r,o)=>{let i=new s.Mesh(t,K.buildDebugMaterial(r));i.renderOrder=e,n.add(i),i.position.fromArray(o)};return r(16711680,[-50,0,0]),r(16711680,[50,0,0]),r(65280,[0,0,-50]),r(65280,[0,0,50]),r(16755200,[5,0,5]),n}createSecondaryDebugMeshes(e){const t=new s.BoxGeometry(3,3,3),n=new s.Object3D;const r=r=>{let o=new s.Mesh(t,K.buildDebugMaterial(12303291));o.renderOrder=e,n.add(o),o.position.fromArray(r)};let o=10;return r([-10,0,-10]),r([-10,0,o]),r([o,0,-10]),r([o,0,o]),n}static buildDebugMaterial(e){const t={color:{type:"v3",value:new s.Color(e)}},n=new s.ShaderMaterial({uniforms:t,vertexShader:"\n            #include <common>\n            varying float ndcDepth;\n\n            void main() {\n                gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position.xyz, 1.0);\n                ndcDepth = gl_Position.z / gl_Position.w;\n                gl_Position.x = gl_Position.x / gl_Position.w;\n                gl_Position.y = gl_Position.y / gl_Position.w;\n                gl_Position.z = 0.0;\n                gl_Position.w = 1.0;\n    \n            }\n        ",fragmentShader:"\n            #include <common>\n            uniform vec3 color;\n            varying float ndcDepth;\n            void main() {\n                gl_FragDepth = (ndcDepth + 1.0) / 2.0;\n                gl_FragColor = vec4(color.rgb, 0.0);\n            }\n        ",transparent:!1,depthTest:!0,depthWrite:!0,side:s.FrontSide});return n.extensions.fragDepth=!0,n}static buildFocusMarkerMaterial(e){const t={color:{type:"v3",value:new s.Color(e)},realFocusPosition:{type:"v3",value:new s.Vector3},viewport:{type:"v2",value:new s.Vector2},opacity:{value:0}};return new s.ShaderMaterial({uniforms:t,vertexShader:"\n            #include <common>\n\n            uniform vec2 viewport;\n            uniform vec3 realFocusPosition;\n\n            varying vec4 ndcPosition;\n            varying vec4 ndcCenter;\n            varying vec4 ndcFocusPosition;\n\n            void main() {\n                float radius = 0.01;\n\n                vec4 viewPosition = modelViewMatrix * vec4(position.xyz, 1.0);\n                vec4 viewCenter = modelViewMatrix * vec4(0.0, 0.0, 0.0, 1.0);\n\n                vec4 viewFocusPosition = modelViewMatrix * vec4(realFocusPosition, 1.0);\n\n                ndcPosition = projectionMatrix * viewPosition;\n                ndcPosition = ndcPosition * vec4(1.0 / ndcPosition.w);\n                ndcCenter = projectionMatrix * viewCenter;\n                ndcCenter = ndcCenter * vec4(1.0 / ndcCenter.w);\n\n                ndcFocusPosition = projectionMatrix * viewFocusPosition;\n                ndcFocusPosition = ndcFocusPosition * vec4(1.0 / ndcFocusPosition.w);\n\n                gl_Position = projectionMatrix * viewPosition;\n\n            }\n        ",fragmentShader:"\n            #include <common>\n            uniform vec3 color;\n            uniform vec2 viewport;\n            uniform float opacity;\n\n            varying vec4 ndcPosition;\n            varying vec4 ndcCenter;\n            varying vec4 ndcFocusPosition;\n\n            void main() {\n                vec2 screenPosition = vec2(ndcPosition) * viewport;\n                vec2 screenCenter = vec2(ndcCenter) * viewport;\n\n                vec2 screenVec = screenPosition - screenCenter;\n\n                float projectedRadius = length(screenVec);\n\n                float lineWidth = 0.0005 * viewport.y;\n                float aaRange = 0.0025 * viewport.y;\n                float radius = 0.06 * viewport.y;\n                float radDiff = abs(projectedRadius - radius) - lineWidth;\n                float alpha = 1.0 - clamp(radDiff / 5.0, 0.0, 1.0); \n\n                gl_FragColor = vec4(color.rgb, alpha * opacity);\n            }\n        ",transparent:!0,depthTest:!1,depthWrite:!1,side:s.FrontSide})}dispose(){this.destroyMeshCursor(),this.destroyFocusMarker(),this.destroyDebugMeshes(),this.destroyControlPlane(),this.destroyRenderTargetCopyObjects(),this.destroySplatRendertarget()}}const q=new s.Vector3(1,0,0),$=new s.Vector3(0,1,0),Z=new s.Vector3(0,0,1);class J{constructor(e=new s.Vector3,t=new s.Vector3){this.origin=new s.Vector3,this.direction=new s.Vector3,this.setParameters(e,t)}setParameters(e,t){this.origin.copy(e),this.direction.copy(t).normalize()}boxContainsPoint(e,t,n){return!(t.x<e.min.x-n||t.x>e.max.x+n||t.y<e.min.y-n||t.y>e.max.y+n||t.z<e.min.z-n||t.z>e.max.z+n)}intersectBox=function(){const e=new s.Vector3,t=[],n=[],r=[];return function(s,o){if(n[0]=this.origin.x,n[1]=this.origin.y,n[2]=this.origin.z,r[0]=this.direction.x,r[1]=this.direction.y,r[2]=this.direction.z,this.boxContainsPoint(s,this.origin,1e-4))return o&&(o.origin.copy(this.origin),o.normal.set(0,0,0),o.distance=-1),!0;for(let i=0;i<3;i++){if(0==r[i])continue;const a=0==i?q:1==i?$:Z,l=r[i]<0?s.max:s.min;let c=-Math.sign(r[i]);t[0]=0==i?l.x:1==i?l.y:l.z;let d=t[0]-n[i];if(d*c<0){const l=(i+1)%3,h=(i+2)%3;if(t[2]=r[l]/r[i]*d+n[l],t[1]=r[h]/r[i]*d+n[h],e.set(t[i],t[h],t[l]),this.boxContainsPoint(s,e,1e-4))return o&&(o.origin.copy(e),o.normal.copy(a).multiplyScalar(c),o.distance=e.sub(this.origin).length()),!0}}return!1}}();intersectSphere=function(){const e=new s.Vector3;return function(t,n,s){e.copy(t).sub(this.origin);const r=e.dot(this.direction),o=r*r,i=e.dot(e)-o,a=n*n;if(i>a)return!1;const l=Math.sqrt(a-i),c=r-l,d=r+l;if(d<0)return!1;let h=c<0?d:c;return s&&(s.origin.copy(this.origin).addScaledVector(this.direction,h),s.normal.copy(s.origin).sub(t).normalize(),s.distance=h),!0}}()}class ee{constructor(){this.origin=new s.Vector3,this.normal=new s.Vector3,this.distance=0,this.splatIndex=0}set(e,t,n,s){this.origin.copy(e),this.normal.copy(t),this.distance=n,this.splatIndex=s}clone(){const e=new ee;return e.origin.copy(this.origin),e.normal.copy(this.normal),e.distance=this.distance,e.splatIndex=this.splatIndex,e}}class te{constructor(e,t,n=!1){this.ray=new J(e,t),this.raycastAgainstTrueSplatEllipsoid=n}setFromCameraAndScreenPosition=function(){const e=new s.Vector2;return function(t,n,s){if(e.x=n.x/s.x*2-1,e.y=(s.y-n.y)/s.y*2-1,t.isPerspectiveCamera)this.ray.origin.setFromMatrixPosition(t.matrixWorld),this.ray.direction.set(e.x,e.y,.5).unproject(t).sub(this.ray.origin).normalize(),this.camera=t;else{if(!t.isOrthographicCamera)throw new Error("Raycaster::setFromCameraAndScreenPosition() -> Unsupported camera type");this.ray.origin.set(n.x,n.y,(t.near+t.far)/(t.near-t.far)).unproject(t),this.ray.direction.set(0,0,-1).transformDirection(t.matrixWorld),this.camera=t}}}();intersectSplatMesh=function(){const e=new s.Matrix4,t=new s.Matrix4,n=new s.Matrix4,r=new J,o=new s.Vector3;return function(s,i=[]){const a=s.getSplatTree();if(a){for(let l=0;l<a.subTrees.length;l++){const c=a.subTrees[l];t.copy(s.matrixWorld),s.dynamicMode&&(s.getSceneTransform(l,n),t.multiply(n)),e.copy(t).invert(),r.origin.copy(this.ray.origin).applyMatrix4(e),r.direction.copy(this.ray.origin).add(this.ray.direction),r.direction.applyMatrix4(e).sub(r.origin).normalize();const d=[];c.rootNode&&this.castRayAtSplatTreeNode(r,a,c.rootNode,d),d.forEach((e=>{e.origin.applyMatrix4(t),e.normal.applyMatrix4(t).normalize(),e.distance=o.copy(e.origin).sub(this.ray.origin).length()})),i.push(...d)}return i.sort(((e,t)=>e.distance>t.distance?1:-1)),i}}}();castRayAtSplatTreeNode=function(){const e=new s.Vector4,t=new s.Vector3,n=new s.Vector3,r=new s.Quaternion,o=new ee,i=1e-7,a=new s.Vector3(0,0,0),l=new s.Matrix4,c=new s.Matrix4,d=new s.Matrix4,h=new s.Matrix4,u=new s.Matrix4,p=new J;return function(s,m,f,g=[]){if(s.intersectBox(f.boundingBox)){if(f.data&&f.data.indexes&&f.data.indexes.length>0)for(let S=0;S<f.data.indexes.length;S++){const y=f.data.indexes[S];if(m.splatMesh.getSplatColor(y,e),m.splatMesh.getSplatCenter(y,t),m.splatMesh.getSplatScaleAndRotation(y,n,r),!(n.x<=i||n.y<=i||n.z<=i))if(this.raycastAgainstTrueSplatEllipsoid){c.makeScale(n.x,n.y,n.z),d.makeRotationFromQuaternion(r);const i=2*Math.log10(e.w);if(l.makeScale(i,i,i),u.copy(l).multiply(d).multiply(c),h.copy(u).invert(),p.origin.copy(s.origin).sub(t).applyMatrix4(h),p.direction.copy(s.origin).add(s.direction).sub(t),p.direction.applyMatrix4(h).sub(p.origin).normalize(),p.intersectSphere(a,1,o)){const e=o.clone();e.splatIndex=y,e.origin.applyMatrix4(u).add(t),g.push(e)}}else{const e=(n.x+n.y+n.z)/3;if(s.intersectSphere(t,e,o)){const e=o.clone();e.splatIndex=y,g.push(e)}}}if(f.children&&f.children.length>0)for(let e of f.children)this.castRayAtSplatTreeNode(s,m,e,g);return g}}}()}class ne{constructor(e,t=new s.Vector3,n=new s.Quaternion,r=new s.Vector3(1,1,1),o=1){this.splatBuffer=e,this.position=t.clone(),this.quaternion=n.clone(),this.scale=r.clone(),this.transform=new s.Matrix4,this.minimumAlpha=o,this.updateTransform()}copyTransformData(e){this.position.copy(e.position),this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.transform.copy(e.transform)}updateTransform(){this.transform.compose(this.position,this.quaternion,this.scale)}}class se{static idGen=0;constructor(e,t,n,r){this.min=(new s.Vector3).copy(e),this.max=(new s.Vector3).copy(t),this.boundingBox=new s.Box3(this.min,this.max),this.center=(new s.Vector3).copy(this.max).sub(this.min).multiplyScalar(.5).add(this.min),this.depth=n,this.children=[],this.data=null,this.id=r||se.idGen++}}class re{constructor(e,t){this.maxDepth=e,this.maxCentersPerNode=t,this.sceneDimensions=new s.Vector3,this.sceneMin=new s.Vector3,this.sceneMax=new s.Vector3,this.rootNode=null,this.nodesWithIndexes=[],this.splatMesh=null}static convertWorkerSubTreeNode(e){const t=(new s.Vector3).fromArray(e.min),n=(new s.Vector3).fromArray(e.max),r=new se(t,n,e.depth,e.id);if(e.data.indexes){r.data={indexes:[]};for(let t of e.data.indexes)r.data.indexes.push(t)}if(e.children)for(let t of e.children)r.children.push(re.convertWorkerSubTreeNode(t));return r}static convertWorkerSubTree(e,t){const n=new re(e.maxDepth,e.maxCentersPerNode);n.sceneMin=(new s.Vector3).fromArray(e.sceneMin),n.sceneMax=(new s.Vector3).fromArray(e.sceneMax),n.splatMesh=t,n.rootNode=re.convertWorkerSubTreeNode(e.rootNode);const r=(e,t)=>{0===e.children.length&&t(e);for(let n of e.children)r(n,t)};return n.nodesWithIndexes=[],r(n.rootNode,(e=>{e.data&&e.data.indexes&&e.data.indexes.length>0&&n.nodesWithIndexes.push(e)})),n}}let oe;function ie(e){let t=0;class n{constructor(e,t){this.min=[e[0],e[1],e[2]],this.max=[t[0],t[1],t[2]]}containsPoint(e){return e[0]>=this.min[0]&&e[0]<=this.max[0]&&e[1]>=this.min[1]&&e[1]<=this.max[1]&&e[2]>=this.min[2]&&e[2]<=this.max[2]}}class s{constructor(e,t){this.maxDepth=e,this.maxCentersPerNode=t,this.sceneDimensions=[],this.sceneMin=[],this.sceneMax=[],this.rootNode=null,this.addedIndexes={},this.nodesWithIndexes=[],this.splatMesh=null}}class r{constructor(e,n,s,r){this.min=[e[0],e[1],e[2]],this.max=[n[0],n[1],n[2]],this.center=[.5*(n[0]-e[0])+e[0],.5*(n[1]-e[1])+e[1],.5*(n[2]-e[2])+e[2]],this.depth=s,this.children=[],this.data=null,this.id=r||t++}}processSplatTreeNode=function(e,t,s,o){const i=t.data.indexes.length;if(i<e.maxCentersPerNode||t.depth>e.maxDepth){const n=[];for(let s=0;s<t.data.indexes.length;s++)e.addedIndexes[t.data.indexes[s]]||(n.push(t.data.indexes[s]),e.addedIndexes[t.data.indexes[s]]=!0);return t.data.indexes=n,t.data.indexes.sort(((e,t)=>e>t?1:-1)),void e.nodesWithIndexes.push(t)}const a=[t.max[0]-t.min[0],t.max[1]-t.min[1],t.max[2]-t.min[2]],l=[.5*a[0],.5*a[1],.5*a[2]],c=[t.min[0]+l[0],t.min[1]+l[1],t.min[2]+l[2]],d=[new n([c[0]-l[0],c[1],c[2]-l[2]],[c[0],c[1]+l[1],c[2]]),new n([c[0],c[1],c[2]-l[2]],[c[0]+l[0],c[1]+l[1],c[2]]),new n([c[0],c[1],c[2]],[c[0]+l[0],c[1]+l[1],c[2]+l[2]]),new n([c[0]-l[0],c[1],c[2]],[c[0],c[1]+l[1],c[2]+l[2]]),new n([c[0]-l[0],c[1]-l[1],c[2]-l[2]],[c[0],c[1],c[2]]),new n([c[0],c[1]-l[1],c[2]-l[2]],[c[0]+l[0],c[1],c[2]]),new n([c[0],c[1]-l[1],c[2]],[c[0]+l[0],c[1],c[2]+l[2]]),new n([c[0]-l[0],c[1]-l[1],c[2]],[c[0],c[1],c[2]+l[2]])],h=[],u=[];for(let e=0;e<d.length;e++)h[e]=0,u[e]=[];const p=[0,0,0];for(let e=0;e<i;e++){const n=t.data.indexes[e],r=s[n];p[0]=o[r],p[1]=o[r+1],p[2]=o[r+2];for(let e=0;e<d.length;e++)d[e].containsPoint(p)&&(h[e]++,u[e].push(n))}for(let e=0;e<d.length;e++){const n=new r(d[e].min,d[e].max,t.depth+1);n.data={indexes:u[e]},t.children.push(n)}t.data={};for(let n of t.children)processSplatTreeNode(e,n,s,o)};const o=(e,t,n)=>{const o=[0,0,0],i=[0,0,0],a=[],l=Math.floor(e.length/4);for(let t=0;t<l;t++){const n=4*t,s=e[n],r=e[n+1],l=e[n+2],c=Math.round(e[n+3]);(0===t||s<o[0])&&(o[0]=s),(0===t||s>i[0])&&(i[0]=s),(0===t||r<o[1])&&(o[1]=r),(0===t||r>i[1])&&(i[1]=r),(0===t||l<o[2])&&(o[2]=l),(0===t||l>i[2])&&(i[2]=l),a.push(c)}const c=new s(t,n);return c.sceneMin=o,c.sceneMax=i,c.rootNode=new r(c.sceneMin,c.sceneMax,0),c.rootNode.data={indexes:a},c};e.onmessage=t=>{t.data.process&&function(t,n,s){const r=[];for(let e of t){const t=Math.floor(e.length/4);for(let n=0;n<t;n++){const t=4*n;r[Math.round(e[t+3])]=t}}const i=[];for(let e of t){const t=o(e,n,s);i.push(t),processSplatTreeNode(t,t.rootNode,r,e)}e.postMessage({subTrees:i})}(t.data.process.centers,t.data.process.maxDepth,t.data.process.maxCentersPerNode)}}class ae{constructor(e,t){this.maxDepth=e,this.maxCentersPerNode=t,this.subTrees=[],this.splatMesh=null}processSplatMesh=function(e,t=(()=>!0),n,r){oe||(oe=new Worker(URL.createObjectURL(new Blob(["(",ie.toString(),")(self)"],{type:"application/javascript"})))),this.splatMesh=e,this.subTrees=[];const o=new s.Vector3,i=(n,s)=>{const r=new Float32Array(4*s);let i=0;for(let a=0;a<s;a++){const s=a+n;if(t(s)){e.getSplatCenter(s,o);const t=4*i;r[t]=o.x,r[t+1]=o.y,r[t+2]=o.z,r[t+3]=s,i++}}return r},a=()=>{oe.terminate(),oe=null},l=t=>!!e.disposed&&(a(),t(),!0);return new Promise((t=>{n&&n(!1),u((()=>{if(l(t))return;const s=[];if(e.dynamicMode){let t=0;for(let n=0;n<e.scenes.length;n++){const r=e.getScene(n).splatBuffer.getSplatCount(),o=i(t,r);s.push(o),t+=r}}else{const t=i(0,e.getSplatCount());s.push(t)}oe.onmessage=n=>{l(t)||n.data.subTrees&&(r&&r(!1),u((()=>{if(!l(t)){for(let t of n.data.subTrees){const n=re.convertWorkerSubTree(t,e);this.subTrees.push(n)}a(),r&&r(!0),u((()=>{t()}))}})))},u((()=>{if(l(t))return;n&&n(!0);const e=s.map((e=>e.buffer));!function(e,t,n,s){oe.postMessage({process:{centers:e,maxDepth:n,maxCentersPerNode:s}},t)}(s,e,this.maxDepth,this.maxCentersPerNode)}))}))}))};countLeaves(){let e=0;return this.visitLeaves((()=>{e++})),e}visitLeaves(e){const t=(e,n)=>{0===e.children.length&&n(e);for(let s of e.children)t(s,n)};for(let n of this.subTrees)t(n.rootNode,e)}}function le(e){const t={};function n(n){if(void 0!==t[n])return t[n];let s;switch(n){case"WEBGL_depth_texture":s=e.getExtension("WEBGL_depth_texture")||e.getExtension("MOZ_WEBGL_depth_texture")||e.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":s=e.getExtension("EXT_texture_filter_anisotropic")||e.getExtension("MOZ_EXT_texture_filter_anisotropic")||e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":s=e.getExtension("WEBGL_compressed_texture_s3tc")||e.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":s=e.getExtension("WEBGL_compressed_texture_pvrtc")||e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:s=e.getExtension(n)}return t[n]=s,s}return{has:function(e){return null!==n(e)},init:function(e){e.isWebGL2?(n("EXT_color_buffer_float"),n("WEBGL_clip_cull_distance")):(n("WEBGL_depth_texture"),n("OES_texture_float"),n("OES_texture_half_float"),n("OES_texture_half_float_linear"),n("OES_standard_derivatives"),n("OES_element_index_uint"),n("OES_vertex_array_object"),n("ANGLE_instanced_arrays")),n("OES_texture_float_linear"),n("EXT_color_buffer_half_float"),n("WEBGL_multisampled_render_to_texture")},get:function(e){const t=n(e);return null===t&&console.warn("THREE.WebGLRenderer: "+e+" extension not supported."),t}}}function ce(e,t,n){let s;function r(t){if("highp"===t){if(e.getShaderPrecisionFormat(e.VERTEX_SHADER,e.HIGH_FLOAT).precision>0&&e.getShaderPrecisionFormat(e.FRAGMENT_SHADER,e.HIGH_FLOAT).precision>0)return"highp";t="mediump"}return"mediump"===t&&e.getShaderPrecisionFormat(e.VERTEX_SHADER,e.MEDIUM_FLOAT).precision>0&&e.getShaderPrecisionFormat(e.FRAGMENT_SHADER,e.MEDIUM_FLOAT).precision>0?"mediump":"lowp"}const o="undefined"!=typeof WebGL2RenderingContext&&"WebGL2RenderingContext"===e.constructor.name;let i=void 0!==n.precision?n.precision:"highp";const a=r(i);a!==i&&(console.warn("THREE.WebGLRenderer:",i,"not supported, using",a,"instead."),i=a);const l=o||t.has("WEBGL_draw_buffers"),c=!0===n.logarithmicDepthBuffer,d=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS),h=e.getParameter(e.MAX_VERTEX_TEXTURE_IMAGE_UNITS),u=e.getParameter(e.MAX_TEXTURE_SIZE),p=e.getParameter(e.MAX_CUBE_MAP_TEXTURE_SIZE),m=e.getParameter(e.MAX_VERTEX_ATTRIBS),f=e.getParameter(e.MAX_VERTEX_UNIFORM_VECTORS),g=e.getParameter(e.MAX_VARYING_VECTORS),S=e.getParameter(e.MAX_FRAGMENT_UNIFORM_VECTORS),y=h>0,A=o||t.has("OES_texture_float");return{isWebGL2:o,drawBuffers:l,getMaxAnisotropy:function(){if(void 0!==s)return s;if(!0===t.has("EXT_texture_filter_anisotropic")){const n=t.get("EXT_texture_filter_anisotropic");s=e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else s=0;return s},getMaxPrecision:r,precision:i,logarithmicDepthBuffer:c,maxTextures:d,maxVertexTextures:h,maxTextureSize:u,maxCubemapSize:p,maxAttributes:m,maxVertexUniforms:f,maxVaryings:g,maxFragmentUniforms:S,vertexTextures:y,floatFragmentTextures:A,floatVertexTextures:y&&A,maxSamples:o?e.getParameter(e.MAX_SAMPLES):0}}const de={Default:0,Gradual:1,Instant:2},he=new s.BufferGeometry,ue=new s.MeshBasicMaterial;class pe extends s.Mesh{constructor(e=!0,t=!1,n=1,r=!0,o=!1,i=!1,a=2048){super(he,ue),this.renderer=void 0,this.halfPrecisionCovariancesOnGPU=t,this.dynamicMode=e,this.devicePixelRatio=n,this.enableDistancesComputationOnGPU=r,this.integerBasedDistancesComputation=o,this.antialiased=i,this.maxScreenSpaceSplatSize=a,this.scenes=[],this.splatTree=null,this.splatDataTextures={},this.distancesTransformFeedback={id:null,vertexShader:null,fragmentShader:null,program:null,centersBuffer:null,transformIndexesBuffer:null,outDistancesBuffer:null,centersLoc:-1,modelViewProjLoc:-1,transformIndexesLoc:-1,transformsLocs:[]},this.globalSplatIndexToLocalSplatIndexMap=[],this.globalSplatIndexToSceneIndexMap=[],this.lastBuildSplatCount=0,this.lastBuildScenes=[],this.lastBuildMaxSplatCount=0,this.lastBuildSceneCount=0,this.firstRenderTime=-1,this.finalBuild=!1,this.webGLUtils=null,this.boundingBox=new s.Box3,this.calculatedSceneCenter=new s.Vector3,this.maxSplatDistanceFromSceneCenter=0,this.visibleRegionBufferRadius=0,this.visibleRegionRadius=0,this.visibleRegionFadeStartRadius=0,this.visibleRegionChanging=!1,this.disposed=!1}static buildMaterial(e=!1,t=!1,n=2048){let r="\n            precision highp float;\n            #include <common>\n\n            attribute uint splatIndex;\n\n            uniform highp sampler2D covariancesTexture;\n            uniform highp usampler2D centersColorsTexture;";e&&(r+=`\n                uniform highp usampler2D transformIndexesTexture;\n                uniform highp mat4 transforms[${E.MaxScenes}];\n                uniform vec2 transformIndexesTextureSize;\n            `),r+="\n            uniform vec2 focal;\n            uniform float inverseFocalAdjustment;\n            uniform vec2 viewport;\n            uniform vec2 basisViewport;\n            uniform vec2 covariancesTextureSize;\n            uniform vec2 centersColorsTextureSize;\n            uniform float visibleRegionRadius;\n            uniform float visibleRegionFadeStartRadius;\n            uniform float firstRenderTime;\n            uniform float currentTime;\n            uniform int fadeInComplete;\n            uniform vec3 sceneCenter;\n\n            varying vec4 vColor;\n            varying vec2 vUv;\n\n            varying vec2 vPosition;\n\n            const float sqrt8 = sqrt(8.0);\n            const float minAlpha = 1.0 / 255.0;\n\n            const vec4 encodeNorm4 = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0);\n            const uvec4 mask4 = uvec4(uint(0x000000FF), uint(0x0000FF00), uint(0x00FF0000), uint(0xFF000000));\n            const uvec4 shift4 = uvec4(0, 8, 16, 24);\n            vec4 uintToRGBAVec (uint u) {\n               uvec4 urgba = mask4 & u;\n               urgba = urgba >> shift4;\n               vec4 rgba = vec4(urgba) * encodeNorm4;\n               return rgba;\n            }\n\n            vec2 getDataUV(in int stride, in int offset, in vec2 dimensions) {\n                vec2 samplerUV = vec2(0.0, 0.0);\n                float d = float(splatIndex * uint(stride) + uint(offset)) / dimensions.x;\n                samplerUV.y = float(floor(d)) / dimensions.y;\n                samplerUV.x = fract(d);\n                return samplerUV;\n            }\n\n            void main () {\n\n                uvec4 sampledCenterColor = texture(centersColorsTexture, getDataUV(1, 0, centersColorsTextureSize));\n                vec3 splatCenter = uintBitsToFloat(uvec3(sampledCenterColor.gba));",r+=e?"\n                    uint transformIndex = texture(transformIndexesTexture, getDataUV(1, 0, transformIndexesTextureSize)).r;\n                    mat4 transform = transforms[transformIndex];\n                    mat4 transformModelViewMatrix = modelViewMatrix * transform;\n                ":"mat4 transformModelViewMatrix = modelViewMatrix;",r+="\n                vec4 viewCenter = transformModelViewMatrix * vec4(splatCenter, 1.0);\n\n                vec4 clipCenter = projectionMatrix * viewCenter;\n\n                float clip = 1.2 * clipCenter.w;\n                if (clipCenter.z < -clip || clipCenter.x < -clip || clipCenter.x > clip || clipCenter.y < -clip || clipCenter.y > clip) {\n                    gl_Position = vec4(0.0, 0.0, 2.0, 1.0);\n                    return;\n                }\n\n                vPosition = position.xy;\n                vColor = uintToRGBAVec(sampledCenterColor.r);\n\n                vec2 sampledCovarianceA = texture(covariancesTexture, getDataUV(3, 0, covariancesTextureSize)).rg;\n                vec2 sampledCovarianceB = texture(covariancesTexture, getDataUV(3, 1, covariancesTextureSize)).rg;\n                vec2 sampledCovarianceC = texture(covariancesTexture, getDataUV(3, 2, covariancesTextureSize)).rg;\n\n                vec3 cov3D_M11_M12_M13 = vec3(sampledCovarianceA.rg, sampledCovarianceB.r);\n                vec3 cov3D_M22_M23_M33 = vec3(sampledCovarianceB.g, sampledCovarianceC.rg);\n\n                // Construct the 3D covariance matrix\n                mat3 Vrk = mat3(\n                    cov3D_M11_M12_M13.x, cov3D_M11_M12_M13.y, cov3D_M11_M12_M13.z,\n                    cov3D_M11_M12_M13.y, cov3D_M22_M23_M33.x, cov3D_M22_M23_M33.y,\n                    cov3D_M11_M12_M13.z, cov3D_M22_M23_M33.y, cov3D_M22_M23_M33.z\n                );\n\n                // Construct the Jacobian of the affine approximation of the projection matrix. It will be used to transform the\n                // 3D covariance matrix instead of using the actual projection matrix because that transformation would\n                // require a non-linear component (perspective division) which would yield a non-gaussian result. (This assumes\n                // the current projection is a perspective projection).\n\n                float s = 1.0 / (viewCenter.z * viewCenter.z);\n                mat3 J = mat3(\n                    focal.x / viewCenter.z, 0., -(focal.x * viewCenter.x) * s,\n                    0., focal.y / viewCenter.z, -(focal.y * viewCenter.y) * s,\n                    0., 0., 0.\n                );\n\n                // Concatenate the projection approximation with the model-view transformation\n                mat3 W = transpose(mat3(transformModelViewMatrix));\n                mat3 T = W * J;\n\n                // Transform the 3D covariance matrix (Vrk) to compute the 2D covariance matrix\n                mat3 cov2Dm = transpose(T) * Vrk * T;\n                ",r+=t?"\n                    float detOrig = cov2Dm[0][0] * cov2Dm[1][1] - cov2Dm[0][1] * cov2Dm[0][1];\n                    cov2Dm[0][0] += 0.3;\n                    cov2Dm[1][1] += 0.3;\n                    float detBlur = cov2Dm[0][0] * cov2Dm[1][1] - cov2Dm[0][1] * cov2Dm[0][1];\n                    float compensation = sqrt(max(detOrig / detBlur, 0.0));\n                ":"\n                    cov2Dm[0][0] += 0.3;\n                    cov2Dm[1][1] += 0.3;\n                    float compensation = 1.0;\n                ",r+=`\n\n                vColor.a *= compensation;\n\n                if (vColor.a < minAlpha) return;\n\n                // We are interested in the upper-left 2x2 portion of the projected 3D covariance matrix because\n                // we only care about the X and Y values. We want the X-diagonal, cov2Dm[0][0],\n                // the Y-diagonal, cov2Dm[1][1], and the correlation between the two cov2Dm[0][1]. We don't\n                // need cov2Dm[1][0] because it is a symetric matrix.\n                vec3 cov2Dv = vec3(cov2Dm[0][0], cov2Dm[0][1], cov2Dm[1][1]);\n\n                vec3 ndcCenter = clipCenter.xyz / clipCenter.w;\n\n                // We now need to solve for the eigen-values and eigen vectors of the 2D covariance matrix\n                // so that we can determine the 2D basis for the splat. This is done using the method described\n                // here: https://people.math.harvard.edu/~knill/teaching/math21b2004/exhibits/2dmatrices/index.html\n                // After calculating the eigen-values and eigen-vectors, we calculate the basis for rendering the splat\n                // by normalizing the eigen-vectors and then multiplying them by (sqrt(8) * eigen-value), which is\n                // equal to scaling them by sqrt(8) standard deviations.\n                //\n                // This is a different approach than in the original work at INRIA. In that work they compute the\n                // max extents of the projected splat in screen space to form a screen-space aligned bounding rectangle\n                // which forms the geometry that is actually rasterized. The dimensions of that bounding box are 3.0\n                // times the maximum eigen-value, or 3 standard deviations. They then use the inverse 2D covariance\n                // matrix (called 'conic') in the CUDA rendering thread to determine fragment opacity by calculating the\n                // full gaussian: exp(-0.5 * (X - mean) * conic * (X - mean)) * splat opacity\n                float a = cov2Dv.x;\n                float d = cov2Dv.z;\n                float b = cov2Dv.y;\n                float D = a * d - b * b;\n                float trace = a + d;\n                float traceOver2 = 0.5 * trace;\n                float term2 = sqrt(max(0.1f, traceOver2 * traceOver2 - D));\n                float eigenValue1 = traceOver2 + term2;\n                float eigenValue2 = traceOver2 - term2;\n\n                if (eigenValue2 <= 0.0) return;\n\n                vec2 eigenVector1 = normalize(vec2(b, eigenValue1 - a));\n                // since the eigen vectors are orthogonal, we derive the second one from the first\n                vec2 eigenVector2 = vec2(eigenVector1.y, -eigenVector1.x);\n\n                // We use sqrt(8) standard deviations instead of 3 to eliminate more of the splat with a very low opacity.\n                vec2 basisVector1 = eigenVector1 * min(sqrt8 * sqrt(eigenValue1), ${parseInt(n)}.0);\n                vec2 basisVector2 = eigenVector2 * min(sqrt8 * sqrt(eigenValue2), ${parseInt(n)}.0);\n\n                if (fadeInComplete == 0) {\n                    float opacityAdjust = 1.0;\n                    float centerDist = length(splatCenter - sceneCenter);\n                    float renderTime = max(currentTime - firstRenderTime, 0.0);\n\n                    float fadeDistance = 0.75;\n                    float distanceLoadFadeInFactor = step(visibleRegionFadeStartRadius, centerDist);\n                    distanceLoadFadeInFactor = (1.0 - distanceLoadFadeInFactor) +\n                                               (1.0 - clamp((centerDist - visibleRegionFadeStartRadius) / fadeDistance, 0.0, 1.0)) *\n                                               distanceLoadFadeInFactor;\n                    opacityAdjust *= distanceLoadFadeInFactor;\n                    vColor.a *= opacityAdjust;\n                }\n\n                vec2 ndcOffset = vec2(vPosition.x * basisVector1 + vPosition.y * basisVector2) *\n                                 basisViewport * 2.0 * inverseFocalAdjustment;\n                gl_Position = vec4(ndcCenter.xy + ndcOffset, ndcCenter.z, 1.0);\n\n                // Scale the position data we send to the fragment shader\n                vPosition *= sqrt8;\n            }`;const o={sceneCenter:{type:"v3",value:new s.Vector3},fadeInComplete:{type:"i",value:0},visibleRegionFadeStartRadius:{type:"f",value:0},visibleRegionRadius:{type:"f",value:0},currentTime:{type:"f",value:0},firstRenderTime:{type:"f",value:0},covariancesTexture:{type:"t",value:null},centersColorsTexture:{type:"t",value:null},focal:{type:"v2",value:new s.Vector2},inverseFocalAdjustment:{type:"f",value:1},viewport:{type:"v2",value:new s.Vector2},basisViewport:{type:"v2",value:new s.Vector2},debugColor:{type:"v3",value:new s.Color},covariancesTextureSize:{type:"v2",value:new s.Vector2(1024,1024)},centersColorsTextureSize:{type:"v2",value:new s.Vector2(1024,1024)}};if(e){o.transformIndexesTexture={type:"t",value:null};const e=[];for(let t=0;t<E.MaxScenes;t++)e.push(new s.Matrix4);o.transforms={type:"mat4",value:e},o.transformIndexesTextureSize={type:"v2",value:new s.Vector2(1024,1024)}}return new s.ShaderMaterial({uniforms:o,vertexShader:r,fragmentShader:"\n            precision highp float;\n            #include <common>\n \n            uniform vec3 debugColor;\n\n            varying vec4 vColor;\n            varying vec2 vUv;\n\n            varying vec2 vPosition;\n\n            void main () {\n                // Compute the positional squared distance from the center of the splat to the current fragment.\n                float A = dot(vPosition, vPosition);\n                // Since the positional data in vPosition has been scaled by sqrt(8), the squared result will be\n                // scaled by a factor of 8. If the squared result is larger than 8, it means it is outside the ellipse\n                // defined by the rectangle formed by vPosition. It also means it's farther\n                // away than sqrt(8) standard deviations from the mean.\n                if (A > 8.0) discard;\n                vec3 color = vColor.rgb;\n\n                // Since the rendered splat is scaled by sqrt(8), the inverse covariance matrix that is part of\n                // the gaussian formula becomes the identity matrix. We're then left with (X - mean) * (X - mean),\n                // and since 'mean' is zero, we have X * X, which is the same as A:\n                float opacity = exp(-0.5 * A) * vColor.a;\n\n                gl_FragColor = vec4(color.rgb, opacity);\n            }",transparent:!0,alphaTest:1,blending:s.NormalBlending,depthTest:!0,depthWrite:!1,side:s.DoubleSide})}static buildGeomtery(e){const t=new s.BufferGeometry;t.setIndex([0,1,2,0,2,3]);const n=new Float32Array(12),r=new s.BufferAttribute(n,3);t.setAttribute("position",r),r.setXYZ(0,-1,-1,0),r.setXYZ(1,-1,1,0),r.setXYZ(2,1,1,0),r.setXYZ(3,1,-1,0),r.needsUpdate=!0;const o=(new s.InstancedBufferGeometry).copy(t),i=new Uint32Array(e),a=new s.InstancedBufferAttribute(i,1,!1);return a.setUsage(s.DynamicDrawUsage),o.setAttribute("splatIndex",a),o.instanceCount=0,o}static buildScenes(e,t){const n=[];n.length=e.length;for(let r=0;r<e.length;r++){const o=e[r],i=t[r]||{};let a=i.position||[0,0,0],l=i.rotation||[0,0,0,1],c=i.scale||[1,1,1];const d=(new s.Vector3).fromArray(a),h=(new s.Quaternion).fromArray(l),u=(new s.Vector3).fromArray(c);n[r]=pe.createScene(o,d,h,u,i.splatAlphaRemovalThreshold||1)}return n}static createScene(e,t,n,s,r){return new ne(e,t,n,s,r)}static buildSplatIndexMaps(e){const t=[],n=[];let s=0;for(let r=0;r<e.length;r++){const o=e[r].getMaxSplatCount();for(let e=0;e<o;e++)t[s]=e,n[s]=r,s++}return{localSplatIndexMap:t,sceneIndexMap:n}}static buildSplatTree=function(e,t=[],n,r){return new Promise((o=>{const i=new ae(8,1e3);console.time("SplatTree build");const a=new s.Vector4;i.processSplatMesh(e,(n=>{e.getSplatColor(n,a);const s=e.getSceneIndexForSplat(n),r=t[s]||1;return a.w>=r}),n,r).then((()=>{console.timeEnd("SplatTree build");let t=0,n=0,s=0,r=0;i.visitLeaves((e=>{const o=e.data.indexes.length;o>0&&(n+=o,s=Math.max(s,o),r++,t++)})),console.log(`SplatTree leaves: ${i.countLeaves()}`),console.log(`SplatTree leaves with splats:${t}`),n/=r,console.log(`Avg splat count per node: ${n}`),console.log(`Total splat count: ${e.getSplatCount()}`),o(i)}))}))};build(e,t,n=!0,r=!1,o,i){this.finalBuild=r;const a=pe.getTotalMaxSplatCountForSplatBuffers(e),l=pe.buildScenes(e,t);if(n)for(let e=0;e<this.scenes.length&&e<l.length;e++){const t=l[e],n=this.getScene(e);t.copyTransformData(n)}this.scenes=l;let c=!0;if((this.scenes.length>1||this.lastBuildSceneCount!==this.scenes.length||this.lastBuildMaxSplatCount!==a||this.scenes[0].splatBuffer!==this.lastBuildScenes[0].splatBuffer)&&(c=!1),!c){c=!1,this.boundingBox=new s.Box3,this.maxSplatDistanceFromSceneCenter=0,this.visibleRegionBufferRadius=0,this.visibleRegionRadius=0,this.visibleRegionFadeStartRadius=0,this.firstRenderTime=-1,this.lastBuildScenes=[],this.lastBuildSplatCount=0,this.lastBuildMaxSplatCount=0,this.disposeMeshData(),this.geometry=pe.buildGeomtery(a),this.material=pe.buildMaterial(this.dynamicMode,this.antialiased,this.maxScreenSpaceSplatSize);const t=pe.buildSplatIndexMaps(e);this.globalSplatIndexToLocalSplatIndexMap=t.localSplatIndexMap,this.globalSplatIndexToSceneIndexMap=t.sceneIndexMap}this.enableDistancesComputationOnGPU&&this.setupDistancesComputationTransformFeedback(),this.resetGPUDataFromSplatBuffers(c);for(let e=0;e<this.scenes.length;e++)this.lastBuildScenes[e]=this.scenes[e];this.lastBuildSplatCount=this.getSplatCount(),this.lastBuildMaxSplatCount=this.getMaxSplatCount(),this.lastBuildSceneCount=this.scenes.length,r&&(this.disposeSplatTree(),pe.buildSplatTree(this,t.map((e=>e.splatAlphaRemovalThreshold||1)),o,i).then((e=>{this.splatTree=e,this.onSplatTreeReadyCallback&&this.onSplatTreeReadyCallback(this.splatTree)})))}dispose(){this.disposeMeshData(),this.disposeTextures(),this.disposeSplatTree(),this.enableDistancesComputationOnGPU&&this.disposeDistancesComputationGPUResources(),this.disposed=!0}disposeMeshData(){this.geometry&&this.geometry!==he&&(this.geometry.dispose(),this.geometry=null),this.material&&(this.material.dispose(),this.material=null)}disposeTextures(){for(let e in this.splatDataTextures)if(this.splatDataTextures.hasOwnProperty(e)){const t=this.splatDataTextures[e];t.texture&&(t.texture.dispose(),t.texture=null)}this.splatDataTextures=null}disposeSplatTree(){this.splatTree=null}getSplatTree(){return this.splatTree}onSplatTreeReady(e){this.onSplatTreeReadyCallback=e}resetGPUDataFromSplatBuffers(e){this.uploadSplatDataToTextures(e),this.enableDistancesComputationOnGPU&&(this.updateGPUCentersBufferForDistancesComputation(e),this.updateGPUTransformIndexesBufferForDistancesComputation())}static computeTextureUpdateRegion(e,t,n,s,r,o){const i=o/r,a=e*i,l=Math.floor(a/n),c=l*n*r,d=t*i,h=Math.floor(d/n);return{dataStart:c,dataEnd:h*n*r+n*r,startRow:l,endRow:h}}updateDataTexture(e,t,n,s,r,o){const i=this.getSplatCount(),a=this.renderer.getContext(),l=pe.computeTextureUpdateRegion(this.lastBuildSplatCount,i-1,t.size.x,t.size.y,s,r),c=l.dataEnd-l.dataStart,d=new e.constructor(e.buffer,l.dataStart*o,c),h=l.endRow-l.startRow+1,u=t.texture,p=this.webGLUtils.convert(u.type),m=this.webGLUtils.convert(u.format,u.colorSpace),f=a.getParameter(a.TEXTURE_BINDING_2D);a.bindTexture(a.TEXTURE_2D,n.__webglTexture),a.texSubImage2D(a.TEXTURE_2D,0,0,l.startRow,t.size.x,h,m,p,d),a.bindTexture(a.TEXTURE_2D,f)}uploadSplatDataToTextures(e){this.checkForMultiSceneUpdateCondition(e,"uploadSplatDataToTextures","isUpdateBuild");const t=this.getMaxSplatCount(),n=this.getSplatCount(),r=(e,t,n,s,r)=>{for(let l=e;l<t;l++){const e=4*l,t=3*l,c=4*l;r[c]=(o=s)[i=e]+(o[i+1]<<8)+(o[i+2]<<16)+(o[i+3]<<24),r[c+1]=a(n[t]),r[c+2]=a(n[t+1]),r[c+3]=a(n[t+2])}var o,i},o=(e,n)=>{const r=new s.Vector2(4096,1024);for(;r.x*r.y*e<t*n;)r.y*=2;return r};if(e){this.fillSplatDataArrays(this.splatDataTextures.baseData.covariances,this.splatDataTextures.baseData.centers,this.splatDataTextures.baseData.colors,void 0,!0);const e=this.splatDataTextures.covariances,t=e.data,s=e.texture,o=6*n;for(let e=6*this.lastBuildSplatCount;e<o;e++){const n=this.splatDataTextures.baseData.covariances[e];t[e]=n}const i=this.renderer?this.renderer.properties.get(s):null;if(i&&i.__webglTexture){const n=this.halfPrecisionCovariancesOnGPU?2:4;this.updateDataTexture(t,e,i,2,6,n)}else s.needsUpdate=!0;const a=this.splatDataTextures.centerColors,l=a.data,c=a.texture;r(this.lastBuildSplatCount,n,this.splatDataTextures.baseData.centers,this.splatDataTextures.baseData.colors,l);const d=this.renderer?this.renderer.properties.get(c):null;if(d&&d.__webglTexture?this.updateDataTexture(l,a,d,4,4,4):c.needsUpdate=!0,this.dynamicMode){const e=this.splatDataTextures.tansformIndexes,t=e.data;for(let e=this.lastBuildSplatCount;e<n;e++)t[e]=this.globalSplatIndexToSceneIndexMap[e];const s=e.texture,r=this.renderer?this.renderer.properties.get(s):null;r&&r.__webglTexture?this.updateDataTexture(t,e,r,1,1,1):s.needsUpdate=!0}}else{this.disposeTextures();const e=new Float32Array(6*t),i=new Float32Array(3*t),a=new Uint8Array(4*t);this.fillSplatDataArrays(e,i,a);const l=o(2,6);let c=this.halfPrecisionCovariancesOnGPU?Uint16Array:Float32Array,d=this.halfPrecisionCovariancesOnGPU?s.HalfFloatType:s.FloatType;const h=new c(l.x*l.y*2);h.set(e);const u=new s.DataTexture(h,l.x,l.y,s.RGFormat,d);u.needsUpdate=!0,this.material.uniforms.covariancesTexture.value=u,this.material.uniforms.covariancesTextureSize.value.copy(l);const p=o(4,4),m=new Uint32Array(p.x*p.y*4);r(0,n,i,a,m);const f=new s.DataTexture(m,p.x,p.y,s.RGBAIntegerFormat,s.UnsignedIntType);if(f.internalFormat="RGBA32UI",f.needsUpdate=!0,this.material.uniforms.centersColorsTexture.value=f,this.material.uniforms.centersColorsTextureSize.value.copy(p),this.material.uniformsNeedUpdate=!0,this.splatDataTextures={baseData:{covariances:e,centers:i,colors:a},covariances:{data:h,texture:u,size:l},centerColors:{data:m,texture:f,size:p}},this.dynamicMode){const e=o(1,4),t=new Uint32Array(e.x*e.y*1);for(let e=0;e<n;e++)t[e]=this.globalSplatIndexToSceneIndexMap[e];const r=new s.DataTexture(t,e.x,e.y,s.RedIntegerFormat,s.UnsignedIntType);r.internalFormat="R32UI",r.needsUpdate=!0,this.material.uniforms.transformIndexesTexture.value=r,this.material.uniforms.transformIndexesTextureSize.value.copy(e),this.material.uniformsNeedUpdate=!0,this.splatDataTextures.tansformIndexes={data:t,texture:r,size:e}}}this.updateVisibleRegion(e)}updateVisibleRegion(e){const t=this.getSplatCount(),n=new s.Vector3;if(!e){const e=new s.Vector3;this.scenes.forEach((t=>{e.add(t.splatBuffer.sceneCenter)})),e.multiplyScalar(1/this.scenes.length),this.calculatedSceneCenter.copy(e),this.material.uniforms.sceneCenter.value.copy(this.calculatedSceneCenter),this.material.uniformsNeedUpdate=!0}for(let s=e?this.lastBuildSplatCount:0;s<t;s++){this.getSplatCenter(s,n,!1);const e=n.sub(this.calculatedSceneCenter).length();e>this.maxSplatDistanceFromSceneCenter&&(this.maxSplatDistanceFromSceneCenter=e)}this.maxSplatDistanceFromSceneCenter-this.visibleRegionBufferRadius>1&&(this.visibleRegionBufferRadius=this.maxSplatDistanceFromSceneCenter,this.visibleRegionRadius=Math.max(this.visibleRegionBufferRadius-1,0)),this.finalBuild&&(this.visibleRegionRadius=this.visibleRegionBufferRadius=this.maxSplatDistanceFromSceneCenter),this.updateVisibleRegionFadeDistance()}updateVisibleRegionFadeDistance(e=de.Default){const t=this.finalBuild?.012:.003,n=e===de.Default?t:.003;this.visibleRegionFadeStartRadius=(this.visibleRegionRadius-this.visibleRegionFadeStartRadius)*n+this.visibleRegionFadeStartRadius;const s=(this.visibleRegionBufferRadius>0?this.visibleRegionFadeStartRadius/this.visibleRegionBufferRadius:0)>.99,r=s||e===de.Instant?1:0;this.material.uniforms.visibleRegionFadeStartRadius.value=this.visibleRegionFadeStartRadius,this.material.uniforms.visibleRegionRadius.value=this.visibleRegionRadius,this.material.uniforms.firstRenderTime.value=this.firstRenderTime,this.material.uniforms.currentTime.value=performance.now(),this.material.uniforms.fadeInComplete.value=r,this.material.uniformsNeedUpdate=!0,this.visibleRegionChanging=!s}updateRenderIndexes(e,t){const n=this.geometry;n.attributes.splatIndex.set(e),n.attributes.splatIndex.needsUpdate=!0,t>0&&-1===this.firstRenderTime&&(this.firstRenderTime=performance.now()),n.instanceCount=t}updateTransforms(){for(let e=0;e<this.scenes.length;e++){this.getScene(e).updateTransform()}}updateUniforms=function(){const e=new s.Vector2;return function(t,n,s,r){if(this.getSplatCount()>0){if(e.set(t.x*this.devicePixelRatio,t.y*this.devicePixelRatio),this.material.uniforms.viewport.value.copy(e),this.material.uniforms.basisViewport.value.set(1/e.x,1/e.y),this.material.uniforms.focal.value.set(n,s),this.material.uniforms.inverseFocalAdjustment.value=r,this.dynamicMode)for(let e=0;e<this.scenes.length;e++)this.material.uniforms.transforms.value[e].copy(this.getScene(e).transform);this.material.uniformsNeedUpdate=!0}}}();getSplatDataTextures(){return this.splatDataTextures}getSplatCount(){return pe.getTotalSplatCountForScenes(this.scenes)}static getTotalSplatCountForScenes(e){let t=0;for(let n of e)n&&n.splatBuffer&&(t+=n.splatBuffer.getSplatCount());return t}static getTotalSplatCountForSplatBuffers(e){let t=0;for(let n of e)t+=n.getSplatCount();return t}getMaxSplatCount(){return pe.getTotalMaxSplatCountForScenes(this.scenes)}static getTotalMaxSplatCountForScenes(e){let t=0;for(let n of e)n&&n.splatBuffer&&(t+=n.splatBuffer.getMaxSplatCount());return t}static getTotalMaxSplatCountForSplatBuffers(e){let t=0;for(let n of e)t+=n.getMaxSplatCount();return t}disposeDistancesComputationGPUResources(){if(!this.renderer)return;const e=this.renderer.getContext();this.distancesTransformFeedback.vao&&(e.deleteVertexArray(this.distancesTransformFeedback.vao),this.distancesTransformFeedback.vao=null),this.distancesTransformFeedback.program&&(e.deleteProgram(this.distancesTransformFeedback.program),e.deleteShader(this.distancesTransformFeedback.vertexShader),e.deleteShader(this.distancesTransformFeedback.fragmentShader),this.distancesTransformFeedback.program=null,this.distancesTransformFeedback.vertexShader=null,this.distancesTransformFeedback.fragmentShader=null),this.disposeDistancesComputationGPUBufferResources(),this.distancesTransformFeedback.id&&(e.deleteTransformFeedback(this.distancesTransformFeedback.id),this.distancesTransformFeedback.id=null)}disposeDistancesComputationGPUBufferResources(){if(!this.renderer)return;const e=this.renderer.getContext();this.distancesTransformFeedback.centersBuffer&&(this.distancesTransformFeedback.centersBuffer=null,e.deleteBuffer(this.distancesTransformFeedback.centersBuffer)),this.distancesTransformFeedback.outDistancesBuffer&&(e.deleteBuffer(this.distancesTransformFeedback.outDistancesBuffer),this.distancesTransformFeedback.outDistancesBuffer=null)}setRenderer(e){if(e!==this.renderer){this.renderer=e;const t=this.renderer.getContext(),n=new le(t),r=new ce(t,n,{});n.init(r),this.webGLUtils=new s.WebGLUtils(t,n,r),this.enableDistancesComputationOnGPU&&this.getSplatCount()>0&&(this.setupDistancesComputationTransformFeedback(),this.updateGPUCentersBufferForDistancesComputation(),this.updateGPUTransformIndexesBufferForDistancesComputation())}}setupDistancesComputationTransformFeedback=function(){let e,t;return function(){const n=this.getMaxSplatCount();if(!this.renderer)return;const s=e!==this.renderer,r=t!==n;if(!s&&!r)return;s?this.disposeDistancesComputationGPUResources():r&&this.disposeDistancesComputationGPUBufferResources();const o=this.renderer.getContext(),i=(e,t,n)=>{const s=e.createShader(t);if(!s)return console.error("Fatal error: gl could not create a shader object."),null;e.shaderSource(s,n),e.compileShader(s);if(!e.getShaderParameter(s,e.COMPILE_STATUS)){let n="unknown";t===e.VERTEX_SHADER?n="vertex shader":t===e.FRAGMENT_SHADER&&(n="fragement shader");const r=e.getShaderInfoLog(s);return console.error("Failed to compile "+n+" with these errors:"+r),e.deleteShader(s),null}return s};let a;this.integerBasedDistancesComputation?(a="#version 300 es\n                in ivec4 center;\n                flat out int distance;",this.dynamicMode?a+=`\n                        in uint transformIndex;\n                        uniform ivec4 transforms[${E.MaxScenes}];\n                        void main(void) {\n                            ivec4 transform = transforms[transformIndex];\n                            distance = center.x * transform.x + center.y * transform.y + center.z * transform.z + transform.w * center.w;\n                        }\n                    `:a+="\n                        uniform ivec3 modelViewProj;\n                        void main(void) {\n                            distance = center.x * modelViewProj.x + center.y * modelViewProj.y + center.z * modelViewProj.z;\n                        }\n                    "):(a="#version 300 es\n                in vec3 center;\n                flat out float distance;",this.dynamicMode?a+=`\n                        in uint transformIndex;\n                        uniform mat4 transforms[${E.MaxScenes}];\n                        void main(void) {\n                            vec4 transformedCenter = transforms[transformIndex] * vec4(center, 1.0);\n                            distance = transformedCenter.z;\n                        }\n                    `:a+="\n                        uniform vec3 modelViewProj;\n                        void main(void) {\n                            distance = center.x * modelViewProj.x + center.y * modelViewProj.y + center.z * modelViewProj.z;\n                        }\n                    ");const l=o.getParameter(o.VERTEX_ARRAY_BINDING),c=o.getParameter(o.CURRENT_PROGRAM);if(s&&(this.distancesTransformFeedback.vao=o.createVertexArray()),o.bindVertexArray(this.distancesTransformFeedback.vao),s){const e=o.createProgram(),t=i(o,o.VERTEX_SHADER,a),n=i(o,o.FRAGMENT_SHADER,"#version 300 es\n                precision lowp float;\n                out vec4 fragColor;\n                void main(){}\n            ");if(!t||!n)throw new Error("Could not compile shaders for distances computation on GPU.");o.attachShader(e,t),o.attachShader(e,n),o.transformFeedbackVaryings(e,["distance"],o.SEPARATE_ATTRIBS),o.linkProgram(e);if(!o.getProgramParameter(e,o.LINK_STATUS)){const s=o.getProgramInfoLog(e);throw console.error("Fatal error: Failed to link program: "+s),o.deleteProgram(e),o.deleteShader(n),o.deleteShader(t),new Error("Could not link shaders for distances computation on GPU.")}this.distancesTransformFeedback.program=e,this.distancesTransformFeedback.vertexShader=t,this.distancesTransformFeedback.vertexShader=n}if(o.useProgram(this.distancesTransformFeedback.program),this.distancesTransformFeedback.centersLoc=o.getAttribLocation(this.distancesTransformFeedback.program,"center"),this.dynamicMode){this.distancesTransformFeedback.transformIndexesLoc=o.getAttribLocation(this.distancesTransformFeedback.program,"transformIndex");for(let e=0;e<this.scenes.length;e++)this.distancesTransformFeedback.transformsLocs[e]=o.getUniformLocation(this.distancesTransformFeedback.program,`transforms[${e}]`)}else this.distancesTransformFeedback.modelViewProjLoc=o.getUniformLocation(this.distancesTransformFeedback.program,"modelViewProj");(s||r)&&(this.distancesTransformFeedback.centersBuffer=o.createBuffer(),o.bindBuffer(o.ARRAY_BUFFER,this.distancesTransformFeedback.centersBuffer),o.enableVertexAttribArray(this.distancesTransformFeedback.centersLoc),this.integerBasedDistancesComputation?o.vertexAttribIPointer(this.distancesTransformFeedback.centersLoc,4,o.INT,0,0):o.vertexAttribPointer(this.distancesTransformFeedback.centersLoc,3,o.FLOAT,!1,0,0),this.dynamicMode&&(this.distancesTransformFeedback.transformIndexesBuffer=o.createBuffer(),o.bindBuffer(o.ARRAY_BUFFER,this.distancesTransformFeedback.transformIndexesBuffer),o.enableVertexAttribArray(this.distancesTransformFeedback.transformIndexesLoc),o.vertexAttribIPointer(this.distancesTransformFeedback.transformIndexesLoc,1,o.UNSIGNED_INT,0,0))),(s||r)&&(this.distancesTransformFeedback.outDistancesBuffer=o.createBuffer()),o.bindBuffer(o.ARRAY_BUFFER,this.distancesTransformFeedback.outDistancesBuffer),o.bufferData(o.ARRAY_BUFFER,4*n,o.STATIC_READ),s&&(this.distancesTransformFeedback.id=o.createTransformFeedback()),o.bindTransformFeedback(o.TRANSFORM_FEEDBACK,this.distancesTransformFeedback.id),o.bindBufferBase(o.TRANSFORM_FEEDBACK_BUFFER,0,this.distancesTransformFeedback.outDistancesBuffer),c&&o.useProgram(c),l&&o.bindVertexArray(l),e=this.renderer,t=n}}();updateGPUCentersBufferForDistancesComputation(e=!1){if(this.checkForMultiSceneUpdateCondition(e,"updateGPUCentersBufferForDistancesComputation","isUpdateBuild"),!this.renderer)return;const t=this.renderer.getContext(),n=t.getParameter(t.VERTEX_ARRAY_BINDING);t.bindVertexArray(this.distancesTransformFeedback.vao);const s=this.integerBasedDistancesComputation?Uint32Array:Float32Array,r=this.integerBasedDistancesComputation?16:12,o=e?this.lastBuildSplatCount*r:0,i=this.integerBasedDistancesComputation?this.getIntegerCenters(!0,e):this.getFloatCenters(!1,e);if(t.bindBuffer(t.ARRAY_BUFFER,this.distancesTransformFeedback.centersBuffer),e)t.bufferSubData(t.ARRAY_BUFFER,o,i);else{const e=new s(16*this.getMaxSplatCount());e.set(i),t.bufferData(t.ARRAY_BUFFER,e,t.STATIC_DRAW)}t.bindBuffer(t.ARRAY_BUFFER,null),n&&t.bindVertexArray(n)}updateGPUTransformIndexesBufferForDistancesComputation(){if(!this.renderer||!this.dynamicMode)return;const e=this.renderer.getContext(),t=e.getParameter(e.VERTEX_ARRAY_BINDING);e.bindVertexArray(this.distancesTransformFeedback.vao),e.bindBuffer(e.ARRAY_BUFFER,this.distancesTransformFeedback.transformIndexesBuffer),e.bufferData(e.ARRAY_BUFFER,this.getTransformIndexes(),e.STATIC_DRAW),e.bindBuffer(e.ARRAY_BUFFER,null),t&&e.bindVertexArray(t)}getTransformIndexes(){const e=new Uint32Array(this.globalSplatIndexToSceneIndexMap.length);return e.set(this.globalSplatIndexToSceneIndexMap),e}fillTransformsArray=function(){const e=[];return function(t){e.length!==t.length&&(e.length=t.length);for(let t=0;t<this.scenes.length;t++){const n=this.getScene(t).transform.elements;for(let s=0;s<16;s++)e[16*t+s]=n[s]}t.set(e)}}();computeDistancesOnGPU=function(){const e=new s.Matrix4;return function(t,n){if(!this.renderer)return;const s=this.renderer.getContext(),r=s.getParameter(s.VERTEX_ARRAY_BINDING),o=s.getParameter(s.CURRENT_PROGRAM);if(s.bindVertexArray(this.distancesTransformFeedback.vao),s.useProgram(this.distancesTransformFeedback.program),s.enable(s.RASTERIZER_DISCARD),this.dynamicMode)for(let n=0;n<this.scenes.length;n++)if(e.copy(this.getScene(n).transform),e.premultiply(t),this.integerBasedDistancesComputation){const t=pe.getIntegerMatrixArray(e),r=[t[2],t[6],t[10],t[14]];s.uniform4i(this.distancesTransformFeedback.transformsLocs[n],r[0],r[1],r[2],r[3])}else s.uniformMatrix4fv(this.distancesTransformFeedback.transformsLocs[n],!1,e.elements);else if(this.integerBasedDistancesComputation){const e=pe.getIntegerMatrixArray(t),n=[e[2],e[6],e[10]];s.uniform3i(this.distancesTransformFeedback.modelViewProjLoc,n[0],n[1],n[2])}else{const e=[t.elements[2],t.elements[6],t.elements[10]];s.uniform3f(this.distancesTransformFeedback.modelViewProjLoc,e[0],e[1],e[2])}s.bindBuffer(s.ARRAY_BUFFER,this.distancesTransformFeedback.centersBuffer),s.enableVertexAttribArray(this.distancesTransformFeedback.centersLoc),this.integerBasedDistancesComputation?s.vertexAttribIPointer(this.distancesTransformFeedback.centersLoc,4,s.INT,0,0):s.vertexAttribPointer(this.distancesTransformFeedback.centersLoc,3,s.FLOAT,!1,0,0),this.dynamicMode&&(s.bindBuffer(s.ARRAY_BUFFER,this.distancesTransformFeedback.transformIndexesBuffer),s.enableVertexAttribArray(this.distancesTransformFeedback.transformIndexesLoc),s.vertexAttribIPointer(this.distancesTransformFeedback.transformIndexesLoc,1,s.UNSIGNED_INT,0,0)),s.bindTransformFeedback(s.TRANSFORM_FEEDBACK,this.distancesTransformFeedback.id),s.bindBufferBase(s.TRANSFORM_FEEDBACK_BUFFER,0,this.distancesTransformFeedback.outDistancesBuffer),s.beginTransformFeedback(s.POINTS),s.drawArrays(s.POINTS,0,this.getSplatCount()),s.endTransformFeedback(),s.bindBufferBase(s.TRANSFORM_FEEDBACK_BUFFER,0,null),s.bindTransformFeedback(s.TRANSFORM_FEEDBACK,null),s.disable(s.RASTERIZER_DISCARD);const i=s.fenceSync(s.SYNC_GPU_COMMANDS_COMPLETE,0);s.flush();const a=new Promise((e=>{const t=()=>{switch(s.clientWaitSync(i,0,0)){case s.TIMEOUT_EXPIRED:return setTimeout(t);case s.WAIT_FAILED:throw new Error("should never get here");default:s.deleteSync(i);const r=s.getParameter(s.VERTEX_ARRAY_BINDING);s.bindVertexArray(this.distancesTransformFeedback.vao),s.bindBuffer(s.ARRAY_BUFFER,this.distancesTransformFeedback.outDistancesBuffer),s.getBufferSubData(s.ARRAY_BUFFER,0,n),s.bindBuffer(s.ARRAY_BUFFER,null),r&&s.bindVertexArray(r),e()}};setTimeout(t)}));return o&&s.useProgram(o),r&&s.bindVertexArray(r),a}}();getLocalSplatParameters(e,t,n){null==n&&(n=!this.dynamicMode),t.splatBuffer=this.getSplatBufferForSplat(e),t.localIndex=this.getSplatLocalIndex(e),t.sceneTransform=n?this.getSceneTransformForSplat(e):null}fillSplatDataArrays(e,t,n,s=void 0,r,o){this.checkForMultiSceneUpdateCondition(r,"fillSplatDataArrays","isUpdateBuild");let i=0;for(let a=0;a<this.scenes.length;a++){null==s&&(s=!this.dynamicMode);let l,c,d=i;r&&(l=this.lastBuildSplatCount,d=o?0:l);const h=this.getScene(a),u=h.splatBuffer,p=s?h.transform:null;e&&u.fillSplatCovarianceArray(e,p,l,c,d,this.halfPrecisionCovariancesOnGPU?1:0),t&&u.fillSplatCenterArray(t,p,l,c,d),n&&u.fillSplatColorArray(n,h.minimumAlpha,p,l,c,d),i+=u.getSplatCount()}}getIntegerCenters(e=!1,t=!1){this.checkForMultiSceneUpdateCondition(t,"getIntegerCenters","isUpdateBuild");const n=this.getSplatCount(),s=t?n-this.lastBuildSplatCount:n,r=new Float32Array(3*s);let o;this.fillSplatDataArrays(null,r,null,void 0,t,t);let i=e?4:3;o=new Int32Array(s*i);for(let t=0;t<s;t++){for(let e=0;e<3;e++)o[t*i+e]=Math.round(1e3*r[3*t+e]);e&&(o[t*i+3]=1e3)}return o}getFloatCenters(e=!1,t=!1){this.checkForMultiSceneUpdateCondition(t,"getFloatCenters","isUpdateBuild");const n=this.getSplatCount(),s=t?n-this.lastBuildSplatCount:n,r=new Float32Array(3*s);if(this.fillSplatDataArrays(null,r,null,void 0,t,t),!e)return r;let o=new Float32Array(4*s);for(let e=0;e<s;e++){for(let t=0;t<3;t++)o[4*e+t]=r[3*e+t];o[4*e+3]=1}return o}getSplatCenter=function(){const e={};return function(t,n,s){this.getLocalSplatParameters(t,e,s),e.splatBuffer.getSplatCenter(e.localIndex,n,e.sceneTransform)}}();getSplatScaleAndRotation=function(){const e={};return function(t,n,s,r){this.getLocalSplatParameters(t,e,r),e.splatBuffer.getSplatScaleAndRotation(e.localIndex,n,s,e.sceneTransform)}}();getSplatColor=function(){const e={};return function(t,n){this.getLocalSplatParameters(t,e),e.splatBuffer.getSplatColor(e.localIndex,n,e.sceneTransform)}}();getSceneTransform(e,t){const n=this.getScene(e);n.updateTransform(),t.copy(n.transform)}getScene(e){if(e<0||e>=this.scenes.length)throw new Error("SplatMesh::getScene() -> Invalid scene index.");return this.scenes[e]}getSplatBufferForSplat(e){return this.getScene(this.globalSplatIndexToSceneIndexMap[e]).splatBuffer}getSceneIndexForSplat(e){return this.globalSplatIndexToSceneIndexMap[e]}getSceneTransformForSplat(e){return this.getScene(this.globalSplatIndexToSceneIndexMap[e]).transform}getSplatLocalIndex(e){return this.globalSplatIndexToLocalSplatIndexMap[e]}static getIntegerMatrixArray(e){const t=e.elements,n=[];for(let e=0;e<16;e++)n[e]=Math.round(1e3*t[e]);return n}checkForMultiSceneUpdateCondition(e,t,n){if(this.scenes.length>1&&e)throw new Error(`${t}() -> '${n}' cannot be true if splat mesh has more than one scene.`)}}function me(e){let t,n,s,r,o,i,a,l,c,d,h,u,p,m,f,g,S,y;e.onmessage=A=>{if(A.data.centers)centers=A.data.centers,transformIndexes=A.data.transformIndexes,r?new Int32Array(n,m,4*i).set(new Int32Array(centers)):new Float32Array(n,m,4*i).set(new Float32Array(centers)),o&&new Uint32Array(n,c,i).set(new Uint32Array(transformIndexes)),e.postMessage({sortSetupComplete:!0});else if(A.data.sort){const C=A.data.sort.splatRenderCount||0,x=A.data.sort.splatSortCount||0,b=A.data.sort.usePrecomputedDistances;let w,T,v;s||(w=A.data.sort.indexesToSort,v=A.data.sort.transforms,b&&(T=A.data.sort.precomputedDistances)),function(A,C,x,b,w,T,v){const F=performance.now();if(!s&&(new Uint32Array(n,a,w.byteLength/y.BytesPerInt).set(w),new Float32Array(n,d,v.byteLength/y.BytesPerFloat).set(v),b)){let e;e=r?new Int32Array(n,h,T.byteLength/y.BytesPerInt):new Float32Array(n,h,T.byteLength/y.BytesPerFloat),e.set(T)}g||(g=new Uint32Array(y.DepthMapRange)),new Float32Array(n,f,16).set(x),new Uint32Array(n,p,y.DepthMapRange).set(g),t.exports.sortIndexes(a,m,h,u,p,f,l,c,d,y.DepthMapRange,A,C,i,b,r,o);const M={sortDone:!0,splatSortCount:A,splatRenderCount:C,sortTime:0};if(!s){const e=new Uint32Array(n,l,C);(!S||S.length<C)&&(S=new Uint32Array(C)),S.set(e),M.sortedIndexes=S}const B=performance.now();M.sortTime=B-F,e.postMessage(M)}(x,C,A.data.sort.modelViewProj,b,w,T,v)}else if(A.data.init){y=A.data.init.Constants,i=A.data.init.splatCount,s=A.data.init.useSharedMemory,r=A.data.init.integerBasedSort,o=A.data.init.dynamicMode;const g=r?4*y.BytesPerInt:4*y.BytesPerFloat,S=new Uint8Array(A.data.init.sorterWasmBytes),C=16*y.BytesPerFloat,x=i*y.BytesPerInt,b=i*g,w=C,T=r?i*y.BytesPerInt:i*y.BytesPerFloat,v=i*y.BytesPerInt,F=i*y.BytesPerInt,M=y.DepthMapRange*y.BytesPerInt*2,B=o?i*y.BytesPerInt:0,E=o?y.MaxScenes*C:0,P=32*y.MemoryPageSize,I=x+b+w+T+v+M+F+B+E+P,D=Math.floor(I/y.MemoryPageSize)+1,R={module:{},env:{memory:new WebAssembly.Memory({initial:2*D,maximum:4*D,shared:!0})}};WebAssembly.compile(S).then((e=>WebAssembly.instantiate(e,R))).then((r=>{t=r,a=0,m=a+x,f=m+b,h=f+w,u=h+T,p=u+v,l=p+M,c=l+F,d=c+B,n=R.env.memory.buffer,s?e.postMessage({sortSetupPhase1Complete:!0,indexesToSortBuffer:n,indexesToSortOffset:a,sortedIndexesBuffer:n,sortedIndexesOffset:l,precomputedDistancesBuffer:n,precomputedDistancesOffset:h,transformsBuffer:n,transformsOffset:d}):e.postMessage({sortSetupPhase1Complete:!0})}))}}}const fe={None:0,VR:1,AR:2};class ge{static createButton(e){const t=document.createElement("button");function n(){t.style.display="",t.style.cursor="auto",t.style.left="calc(50% - 75px)",t.style.width="150px",t.onmouseenter=null,t.onmouseleave=null,t.onclick=null}function s(e){e.style.position="absolute",e.style.bottom="20px",e.style.padding="12px 6px",e.style.border="1px solid #fff",e.style.borderRadius="4px",e.style.background="rgba(0,0,0,0.1)",e.style.color="#fff",e.style.font="normal 13px sans-serif",e.style.textAlign="center",e.style.opacity="0.5",e.style.outline="none",e.style.zIndex="999"}if("xr"in navigator)return t.id="VRButton",t.style.display="none",s(t),navigator.xr.isSessionSupported("immersive-vr").then((function(s){s?function(){let n=null;async function s(s){s.addEventListener("end",r),await e.xr.setSession(s),t.textContent="EXIT VR",n=s}function r(){n.removeEventListener("end",r),t.textContent="ENTER VR",n=null}t.style.display="",t.style.cursor="pointer",t.style.left="calc(50% - 50px)",t.style.width="100px",t.textContent="ENTER VR";const o={optionalFeatures:["local-floor","bounded-floor","hand-tracking","layers"]};t.onmouseenter=function(){t.style.opacity="1.0"},t.onmouseleave=function(){t.style.opacity="0.5"},t.onclick=function(){null===n?navigator.xr.requestSession("immersive-vr",o).then(s):(n.end(),void 0!==navigator.xr.offerSession&&navigator.xr.offerSession("immersive-vr",o).then(s).catch((e=>{console.warn(e)})))},void 0!==navigator.xr.offerSession&&navigator.xr.offerSession("immersive-vr",o).then(s).catch((e=>{console.warn(e)}))}():(n(),t.textContent="VR NOT SUPPORTED"),s&&ge.xrSessionIsGranted&&t.click()})).catch((function(e){n(),console.warn("Exception when trying to call xr.isSessionSupported",e),t.textContent="VR NOT ALLOWED"})),t;{const e=document.createElement("a");return!1===window.isSecureContext?(e.href=document.location.href.replace(/^http:/,"https:"),e.innerHTML="WEBXR NEEDS HTTPS"):(e.href="https://immersiveweb.dev/",e.innerHTML="WEBXR NOT AVAILABLE"),e.style.left="calc(50% - 90px)",e.style.width="180px",e.style.textDecoration="none",s(e),e}}static registerSessionGrantedListener(){if("undefined"!=typeof navigator&&"xr"in navigator){if(/WebXRViewer\//i.test(navigator.userAgent))return;navigator.xr.addEventListener("sessiongranted",(()=>{ge.xrSessionIsGranted=!0}))}}}ge.xrSessionIsGranted=!1,ge.registerSessionGrantedListener();class Se{static createButton(e,t={}){const n=document.createElement("button");function s(){n.style.display="",n.style.cursor="auto",n.style.left="calc(50% - 75px)",n.style.width="150px",n.onmouseenter=null,n.onmouseleave=null,n.onclick=null}function r(e){e.style.position="absolute",e.style.bottom="20px",e.style.padding="12px 6px",e.style.border="1px solid #fff",e.style.borderRadius="4px",e.style.background="rgba(0,0,0,0.1)",e.style.color="#fff",e.style.font="normal 13px sans-serif",e.style.textAlign="center",e.style.opacity="0.5",e.style.outline="none",e.style.zIndex="999"}if("xr"in navigator)return n.id="ARButton",n.style.display="none",r(n),navigator.xr.isSessionSupported("immersive-ar").then((function(r){r?function(){if(void 0===t.domOverlay){const e=document.createElement("div");e.style.display="none",document.body.appendChild(e);const n=document.createElementNS("http://www.w3.org/2000/svg","svg");n.setAttribute("width",38),n.setAttribute("height",38),n.style.position="absolute",n.style.right="20px",n.style.top="20px",n.addEventListener("click",(function(){s.end()})),e.appendChild(n);const r=document.createElementNS("http://www.w3.org/2000/svg","path");r.setAttribute("d","M 12,12 L 28,28 M 28,12 12,28"),r.setAttribute("stroke","#fff"),r.setAttribute("stroke-width",2),n.appendChild(r),void 0===t.optionalFeatures&&(t.optionalFeatures=[]),t.optionalFeatures.push("dom-overlay"),t.domOverlay={root:e}}let s=null;async function r(r){r.addEventListener("end",o),e.xr.setReferenceSpaceType("local"),await e.xr.setSession(r),n.textContent="STOP AR",t.domOverlay.root.style.display="",s=r}function o(){s.removeEventListener("end",o),n.textContent="START AR",t.domOverlay.root.style.display="none",s=null}n.style.display="",n.style.cursor="pointer",n.style.left="calc(50% - 50px)",n.style.width="100px",n.textContent="START AR",n.onmouseenter=function(){n.style.opacity="1.0"},n.onmouseleave=function(){n.style.opacity="0.5"},n.onclick=function(){null===s?navigator.xr.requestSession("immersive-ar",t).then(r):(s.end(),void 0!==navigator.xr.offerSession&&navigator.xr.offerSession("immersive-ar",t).then(r).catch((e=>{console.warn(e)})))},void 0!==navigator.xr.offerSession&&navigator.xr.offerSession("immersive-ar",t).then(r).catch((e=>{console.warn(e)}))}():(s(),n.textContent="AR NOT SUPPORTED")})).catch((function(e){s(),console.warn("Exception when trying to call xr.isSessionSupported",e),n.textContent="AR NOT ALLOWED"})),n;{const e=document.createElement("a");return!1===window.isSecureContext?(e.href=document.location.href.replace(/^http:/,"https:"),e.innerHTML="WEBXR NEEDS HTTPS"):(e.href="https://immersiveweb.dev/",e.innerHTML="WEBXR NOT AVAILABLE"),e.style.left="calc(50% - 90px)",e.style.width="180px",e.style.textDecoration="none",r(e),e}}}const ye={Always:0,OnChange:1,Never:2};class Ae{constructor(e={}){e.cameraUp||(e.cameraUp=[0,1,0]),this.cameraUp=(new s.Vector3).fromArray(e.cameraUp),e.initialCameraPosition||(e.initialCameraPosition=[0,10,15]),this.initialCameraPosition=(new s.Vector3).fromArray(e.initialCameraPosition),e.initialCameraLookAt||(e.initialCameraLookAt=[0,0,0]),this.initialCameraLookAt=(new s.Vector3).fromArray(e.initialCameraLookAt),this.dropInMode=e.dropInMode||!1,void 0!==e.selfDrivenMode&&null!==e.selfDrivenMode||(e.selfDrivenMode=!0),this.selfDrivenMode=e.selfDrivenMode&&!this.dropInMode,this.selfDrivenUpdateFunc=this.selfDrivenUpdate.bind(this),void 0===e.useBuiltInControls&&(e.useBuiltInControls=!0),this.useBuiltInControls=e.useBuiltInControls,this.rootElement=e.rootElement,this.ignoreDevicePixelRatio=e.ignoreDevicePixelRatio||!1,this.devicePixelRatio=this.ignoreDevicePixelRatio?1:window.devicePixelRatio,this.halfPrecisionCovariancesOnGPU=e.halfPrecisionCovariancesOnGPU||!1,this.threeScene=e.threeScene,this.renderer=e.renderer,this.camera=e.camera,this.gpuAcceleratedSort=e.gpuAcceleratedSort,!0!==this.gpuAcceleratedSort&&!1!==this.gpuAcceleratedSort&&(this.isMobile()?this.gpuAcceleratedSort=!1:this.gpuAcceleratedSort=!0),void 0!==e.integerBasedSort&&null!==e.integerBasedSort||(e.integerBasedSort=!0),this.integerBasedSort=e.integerBasedSort,void 0!==e.sharedMemoryForWorkers&&null!==e.sharedMemoryForWorkers||(e.sharedMemoryForWorkers=!0),this.sharedMemoryForWorkers=e.sharedMemoryForWorkers;const t=!!e.dynamicScene,n=e.antialiased||!1;this.webXRMode=e.webXRMode||fe.None,this.webXRMode!==fe.None&&(this.gpuAcceleratedSort=!1),this.renderMode=e.renderMode||ye.Always,this.sceneRevealMode=e.sceneRevealMode||de.Default,this.focalAdjustment=e.focalAdjustment||1,this.maxScreenSpaceSplatSize=e.maxScreenSpaceSplatSize||2048,this.splatMesh=new pe(t,this.halfPrecisionCovariancesOnGPU,this.devicePixelRatio,this.gpuAcceleratedSort,this.integerBasedSort,n,this.maxScreenSpaceSplatSize),this.controls=null,this.showMeshCursor=!1,this.showControlPlane=!1,this.showInfo=!1,this.sceneHelper=null,this.sortWorker=null,this.sortRunning=!1,this.splatRenderCount=0,this.sortWorkerIndexesToSort=null,this.sortWorkerSortedIndexes=null,this.sortWorkerPrecomputedDistances=null,this.sortWorkerTransforms=null,this.runAfterFirstSort=[],this.selfDrivenModeRunning=!1,this.splatRenderingInitialized=!1,this.raycaster=new te,this.infoPanel=null,this.currentFPS=0,this.lastSortTime=0,this.consecutiveRenderFrames=0,this.previousCameraTarget=new s.Vector3,this.nextCameraTarget=new s.Vector3,this.mousePosition=new s.Vector2,this.mouseDownPosition=new s.Vector2,this.mouseDownTime=null,this.resizeObserver=null,this.mouseMoveListener=null,this.mouseDownListener=null,this.mouseUpListener=null,this.keyDownListener=null,this.sortPromise=null,this.sortPromiseResolver=null,this.downloadPromisesToAbort={},this.splatSceneLoadPromise=null,this.loadingSpinner=new G(null,this.rootElement||document.body),this.loadingSpinner.hide(),this.loadingProgressBar=new Q(this.rootElement||document.body),this.loadingProgressBar.hide(),this.infoPanel=new Y(this.rootElement||document.body),this.infoPanel.hide(),this.usingExternalCamera=!(!this.dropInMode&&!this.camera),this.usingExternalRenderer=!(!this.dropInMode&&!this.renderer),this.initialized=!1,this.disposing=!1,this.disposed=!1,this.dropInMode||this.init()}init(){if(this.initialized)return;this.rootElement||(this.usingExternalRenderer?this.rootElement=this.renderer.domElement.parentElement||document.body:(this.rootElement=document.createElement("div"),this.rootElement.style.width="100%",this.rootElement.style.height="100%",this.rootElement.style.position="absolute",document.body.appendChild(this.rootElement)));const e=new s.Vector2;this.getRenderDimensions(e),this.usingExternalCamera||(this.camera=new s.PerspectiveCamera(50,e.x/e.y,.1,500),this.camera.position.copy(this.initialCameraPosition),this.camera.up.copy(this.cameraUp).normalize(),this.camera.lookAt(this.initialCameraLookAt)),this.usingExternalRenderer||(this.renderer=new s.WebGLRenderer({antialias:!1,precision:"highp"}),this.renderer.setPixelRatio(this.devicePixelRatio),this.renderer.autoClear=!0,this.renderer.setClearColor(new s.Color(0),0),this.renderer.setSize(e.x,e.y),this.resizeObserver=new ResizeObserver((()=>{this.getRenderDimensions(e),this.renderer.setSize(e.x,e.y),this.forceRenderNextFrame()})),this.resizeObserver.observe(this.rootElement),this.rootElement.appendChild(this.renderer.domElement)),this.webXRMode&&(this.webXRMode===fe.VR?this.rootElement.appendChild(ge.createButton(this.renderer)):this.webXRMode===fe.AR&&this.rootElement.appendChild(Se.createButton(this.renderer)),this.renderer.xr.enabled=!0,this.camera.position.copy(this.initialCameraPosition),this.camera.up.copy(this.cameraUp).normalize(),this.camera.lookAt(this.initialCameraLookAt)),this.threeScene=this.threeScene||new s.Scene,this.sceneHelper=new K(this.threeScene),this.sceneHelper.setupMeshCursor(),this.sceneHelper.setupFocusMarker(),this.sceneHelper.setupControlPlane(),this.useBuiltInControls&&this.webXRMode===fe.None&&(this.controls=new W(this.camera,this.renderer.domElement),this.controls.listenToKeyEvents(window),this.controls.rotateSpeed=.5,this.controls.maxPolarAngle=.75*Math.PI,this.controls.minPolarAngle=.1,this.controls.enableDamping=!0,this.controls.dampingFactor=.05,this.controls.target.copy(this.initialCameraLookAt),this.mouseMoveListener=this.onMouseMove.bind(this),this.renderer.domElement.addEventListener("pointermove",this.mouseMoveListener,!1),this.mouseDownListener=this.onMouseDown.bind(this),this.renderer.domElement.addEventListener("pointerdown",this.mouseDownListener,!1),this.mouseUpListener=this.onMouseUp.bind(this),this.renderer.domElement.addEventListener("pointerup",this.mouseUpListener,!1),this.keyDownListener=this.onKeyDown.bind(this),window.addEventListener("keydown",this.keyDownListener,!1)),this.loadingProgressBar.setContainer(this.rootElement),this.loadingSpinner.setContainer(this.rootElement),this.infoPanel.setContainer(this.rootElement),this.initialized=!0}removeEventHandlers(){this.useBuiltInControls&&(this.renderer.domElement.removeEventListener("pointermove",this.mouseMoveListener),this.mouseMoveListener=null,this.renderer.domElement.removeEventListener("pointerdown",this.mouseDownListener),this.mouseDownListener=null,this.renderer.domElement.removeEventListener("pointerup",this.mouseUpListener),this.mouseUpListener=null,window.removeEventListener("keydown",this.keyDownListener),this.keyDownListener=null)}setRenderMode(e){this.renderMode=e}onKeyDown=function(){const e=new s.Vector3,t=new s.Matrix4,n=new s.Matrix4;return function(s){switch(e.set(0,0,-1),e.transformDirection(this.camera.matrixWorld),t.makeRotationAxis(e,Math.PI/128),n.makeRotationAxis(e,-Math.PI/128),s.code){case"KeyG":this.focalAdjustment+=.02,this.forceRenderNextFrame();break;case"KeyF":this.focalAdjustment-=.02,this.forceRenderNextFrame();break;case"ArrowLeft":this.camera.up.transformDirection(t);break;case"ArrowRight":this.camera.up.transformDirection(n);break;case"KeyC":this.showMeshCursor=!this.showMeshCursor;break;case"KeyP":this.showControlPlane=!this.showControlPlane;break;case"KeyI":this.showInfo=!this.showInfo,this.showInfo?this.infoPanel.show():this.infoPanel.hide()}}}();onMouseMove(e){this.mousePosition.set(e.offsetX,e.offsetY)}onMouseDown(){this.mouseDownPosition.copy(this.mousePosition),this.mouseDownTime=d()}onMouseUp=function(){const e=new s.Vector2;return function(t){e.copy(this.mousePosition).sub(this.mouseDownPosition);d()-this.mouseDownTime<.5&&e.length()<2&&this.onMouseClick(t)}}();onMouseClick(e){this.mousePosition.set(e.offsetX,e.offsetY),this.checkForFocalPointChange()}checkForFocalPointChange=function(){const e=new s.Vector2,t=new s.Vector3,n=[];return function(){if(!this.transitioningCameraTarget&&(this.getRenderDimensions(e),n.length=0,this.raycaster.setFromCameraAndScreenPosition(this.camera,this.mousePosition,e),this.raycaster.intersectSplatMesh(this.splatMesh,n),n.length>0)){const e=n[0].origin;t.copy(e).sub(this.camera.position),t.length()>.75&&(this.previousCameraTarget.copy(this.controls.target),this.nextCameraTarget.copy(e),this.transitioningCameraTarget=!0,this.transitioningCameraTargetStartTime=d())}}}();getRenderDimensions(e){this.rootElement?(e.x=this.rootElement.offsetWidth,e.y=this.rootElement.offsetHeight):this.renderer.getSize(e)}updateSplatMesh=function(){const e=new s.Vector2;return function(){if(!this.splatMesh)return;if(this.splatMesh.getSplatCount()>0){this.splatMesh.updateTransforms(),this.getRenderDimensions(e);const t=.5*this.camera.projectionMatrix.elements[0]*this.devicePixelRatio*e.x,n=.5*this.camera.projectionMatrix.elements[5]*this.devicePixelRatio*e.y,s=this.focalAdjustment,r=1/s;this.splatMesh.updateUniforms(e,t*s,n*s,r)}}}();isLoading(){return Object.keys(this.downloadPromisesToAbort)>0||null!==this.splatSceneLoadPromise}isDisposingOrDisposed(){return this.disposing||this.disposed}clearSplatSceneLoadPromise(){this.splatSceneLoadPromise=null}setSplatSceneLoadPromise(e){this.splatSceneLoadPromise=e}addSplatScene(e,t={}){if(this.isLoading())throw new Error("Cannot add splat scene while another load is already in progress.");if(this.isDisposingOrDisposed())throw new Error("Cannot add splat scene after dispose() is called.");let n=t.format;null==n&&(n=L(e));const s=Ae.isStreamable(n)&&t.streamView,r={rotation:t.rotation||t.orientation,position:t.position,scale:t.scale,splatAlphaRemovalThreshold:t.splatAlphaRemovalThreshold};let o=t.showLoadingUI;!1!==o&&(o=!0);let i=null;o&&(i=this.loadingSpinner.addTask("Downloading..."));let a=!1,l=0;return(s?this.loadSplatSceneToSplatBufferStreaming.bind(this):this.loadSplatSceneToSplatBufferNonStreaming.bind(this))(e,n,t.splatAlphaRemovalThreshold,((e,n,c)=>(!s&&t.onProgress&&t.onProgress(0,"0%",M),this.addSplatBuffers([e],[r],c,n&&o,o).then((()=>{!s&&t.onProgress&&t.onProgress(100,"100%",M),o&&((n&&s||c&&!s)&&this.runAfterFirstSort.push((()=>{this.loadingSpinner.removeTask(i),c||a||this.loadingProgressBar.show()})),s&&(c?(a=!0,this.loadingProgressBar.hide()):this.loadingProgressBar.setProgress(l)))})))).bind(this),((e,n,r)=>{if(o)if(r===F)if(l=e,100==e)this.loadingSpinner.setMessageForTask(i,"Download complete!");else if(s)this.loadingSpinner.setMessageForTask(i,"Downloading splats...");else{const e=n?`: ${n}`:"...";this.loadingSpinner.setMessageForTask(i,`Downloading${e}`)}else r===M?this.loadingSpinner.setMessageForTask(i,"Processing splats..."):this.loadingSpinner.setMessageForTask(i,"Ready!");t.onProgress&&t.onProgress(e,n,r)}),(()=>{this.loadingProgressBar.hide(),this.loadingSpinner.removeAllTasks()}).bind(this))}addSplatScenes(e,t=!0,n=void 0){if(this.isLoading())throw new Error("Cannot add splat scene while another load is already in progress.");if(this.isDisposingOrDisposed())throw new Error("Cannot add splat scene after dispose() is called.");const s=e.length,r=[];t&&this.loadingSpinner.show();const a=(e,o,i)=>{r[e]=o;let a=0;for(let e=0;e<s;e++)a+=r[e]||0;a/=s,i=`${a.toFixed(2)}%`,t&&(100==a?this.loadingSpinner.setMessage("Download complete!"):this.loadingSpinner.setMessage(`Downloading: ${i}`)),n&&n(a,i,F)},l=[],c=[],d=[];for(let t=0;t<e.length;t++){let n=e[t].format;null==n&&(n=L(e[t].path));const s=this.loadSplatSceneToSplatBuffer(e[t].path,e[t].splatAlphaRemovalThreshold,a.bind(this,t),!1,void 0,n);d.push(s.abortHandler),l.push(s),c.push(s.promise),this.downloadPromisesToAbort[s.id]=s}const h=new o(((s,r)=>{Promise.all(c).then((r=>{t&&this.loadingSpinner.hide(),n&&options.onProgress(0,"0%",M),this.addSplatBuffers(r,e,!0,t,t).then((()=>{n&&n(100,"100%",M),s(),this.clearSplatSceneLoadPromise()}))})).catch((e=>{t&&this.loadingSpinner.hide(),e instanceof i?s():r(new Error("Viewer::addSplatScenes -> Could not load one or more splat scenes.")),this.clearSplatSceneLoadPromise()})).finally((()=>{for(let e of l)delete this.downloadPromisesToAbort[e.id]}))}),(()=>{for(let e of d)e()}));return this.setSplatSceneLoadPromise(h),h}loadSplatSceneToSplatBufferNonStreaming(e,t,n,s,r,o){const a=()=>{delete this.downloadPromisesToAbort[l.id]},l=this.loadSplatSceneToSplatBuffer(e,n,r,!1,void 0,t).then((e=>(a(),s(e,!0,!0).then((()=>{this.clearSplatSceneLoadPromise()}))))).catch((t=>{if(o&&o(),this.clearSplatSceneLoadPromise(),a(),!(t instanceof i))throw new Error(`Viewer::addSplatScene -> Could not load file ${e}`)}));return this.downloadPromisesToAbort[l.id]=l,this.setSplatSceneLoadPromise(l),l}loadSplatSceneToSplatBufferStreaming(e,t,n,s,r,a){let l,c,d,h,u=0,p=!1;const m=[],f=()=>{if(m.length>0&&!p&&!this.isDisposingOrDisposed()){p=!0;const e=m.shift();s(e.splatBuffer,e.firstBuild,e.finalBuild).then((()=>{p=!1,e.firstBuild?l():e.finalBuild&&(d(),this.clearSplatSceneLoadPromise()),window.setTimeout((()=>{f()}),1)}))}};let g=this.loadSplatSceneToSplatBuffer(e,n,r,!0,((e,t)=>{this.isDisposingOrDisposed()||(m.push({splatBuffer:e,firstBuild:0===u,finalBuild:t}),u++,f())}),t);const S=new o(((e,t)=>{l=e,c=t;const n=()=>{delete this.downloadPromisesToAbort[g.id]};g.then((()=>{n()})).catch((e=>{e instanceof i||(h(e),c(e)),a&&a(),this.clearSplatSceneLoadPromise(),n()}))}),g.abortHandler);return this.downloadPromisesToAbort[g.id]=g,this.setSplatSceneLoadPromise(new o(((e,t)=>{d=e,h=t}))),S}loadSplatSceneToSplatBuffer(e,t=1,n=void 0,s=!1,r=void 0,i){return i===O.Splat?R.loadFromURL(e,n,s,r,t,0,!1):i===O.KSplat?k.loadFromURL(e,n,s,r):i===O.Ply?I.loadFromURL(e,n,s,r,t,0):o.reject(new Error(`Viewer::loadSplatSceneToSplatBuffer -> File format not supported: ${e}`))}static isStreamable(e){return e===O.Splat||e===O.KSplat||e===O.Ply}addSplatBuffers=function(){let e=0,t=null;return function(n,s=[],r=!0,o=!0,i=!0){if(this.isDisposingOrDisposed())return Promise.resolve();this.splatRenderingInitialized=!1,e++;const a=n=>{if(!this.isDisposingOrDisposed()){if(e--,0===e&&(null!==t&&(this.loadingSpinner.removeTask(t),t=null),this.splatRenderingInitialized=!0),!this.gpuAcceleratedSort){const e=this.integerBasedSort?this.splatMesh.getIntegerCenters(!0):this.splatMesh.getFloatCenters(!0),t=this.splatMesh.getTransformIndexes();this.sortWorker.postMessage({centers:e.buffer,transformIndexes:t.buffer})}this.forceSort=!0,n()}};return(()=>new Promise((e=>{o&&(t=this.loadingSpinner.addTask("Processing splats...")),u((()=>{if(this.isDisposingOrDisposed())e();else{this.addSplatBuffersToMesh(n,s,r,i);const t=this.splatMesh.getMaxSplatCount();this.sortWorker&&this.sortWorker.maxSplatCount!==t&&this.disposeSortWorker(),this.sortWorker?a(e):this.setupSortWorker(this.splatMesh).then((()=>{a(e)}))}}))})))()}}();disposeSortWorker(){this.sortWorker&&this.sortWorker.terminate(),this.sortWorker=null,this.sortRunning=!1}addSplatBuffersToMesh(e,t,n=!0,s=!1){if(this.isDisposingOrDisposed())return;const r=this.splatMesh.splatBuffers||[],o=this.splatMesh.splatBufferOptions||[];let i;r.push(...e),o.push(...t),this.renderer&&this.splatMesh.setRenderer(this.renderer);this.splatMesh.build(r,o,!0,n,(e=>{if(this.isDisposingOrDisposed())return;const t=this.splatMesh.getSplatCount();s&&t>=15e5&&(e||i||(this.loadingSpinner.setMinimized(!0,!0),i=this.loadingSpinner.addTask("Optimizing splats...")))}),(e=>{this.isDisposingOrDisposed()||e&&i&&this.loadingSpinner.removeTask(i)})),this.splatMesh.frustumCulled=!1}setupSortWorker(e){if(!this.isDisposingOrDisposed())return new Promise((t=>{const n=this.integerBasedSort?Int32Array:Float32Array,s=e.getSplatCount(),r=e.getMaxSplatCount();this.sortWorker=function(e,t,n,s){const r=new Worker(URL.createObjectURL(new Blob(["(",me.toString(),")(self)"],{type:"application/javascript"}))),o=atob("AGFzbQEAAAAADAZkeWxpbmsAAAAAAAEbA2AAAGAQf39/f39/f39/f39/f39/fwBgAAF/AhIBA2VudgZtZW1vcnkCAwCAgAQDBAMAAQIHOQMRX193YXNtX2NhbGxfY3RvcnMAAAtzb3J0SW5kZXhlcwABE2Vtc2NyaXB0ZW5fdGxzX2luaXQAAgrHEAMDAAELuxAFAXwDewJ/A30CfiALIAprIQwCQCAOBEAgDQRAQfj///8HIQ5BiICAgHghDSALIAxNDQIgDCEBA0AgAyABQQJ0IgVqIAIgACAFaigCAEECdGooAgAiBTYCACAFIA4gBSAOSBshDiAFIA0gBSANShshDSABQQFqIgEgC0cNAAsMAgsgDwRAQfj///8HIQ5BiICAgHghDSALIAxNDQJBfyEPIAwhAgNAIA8gByAAIAJBAnQiFGooAgAiFUECdGooAgAiCkcEQAJ+IAX9CQIIIAggCkEGdGoiD/0JAgAgDyoCEP0gASAPKgIg/SACIA8qAjD9IAP95gEgBf0JAhggD/0JAgQgDyoCFP0gASAPKgIk/SACIA8qAjT9IAP95gH95AEgBf0JAiggD/0JAgggDyoCGP0gASAPKgIo/SACIA8qAjj9IAP95gH95AEgBf0JAjggD/0JAgwgDyoCHP0gASAPKgIs/SACIA8qAjz9IAP95gH95AEiEf0fArv9FCAR/R8Du/0iAf0MAAAAAABAj0AAAAAAAECPQCIS/fIBIhP9IQEiEJlEAAAAAAAA4ENjBEAgELAMAQtCgICAgICAgICAfwshGQJ+IBP9IQAiEJlEAAAAAAAA4ENjBEAgELAMAQtCgICAgICAgICAfwv9EiETAn4gEf0fALv9FCAR/R8Bu/0iASAS/fIBIhH9IQEiEJlEAAAAAAAA4ENjBEAgELAMAQtCgICAgICAgICAfwshGiATIBn9HgEhEgJ+IBH9IQAiEJlEAAAAAAAA4ENjBEAgELAMAQtCgICAgICAgICAfwv9EiAa/R4BIBL9DQABAgMICQoLEBESExgZGhshEiAKIQ8LIAMgFGogASAVQQR0av0AAAAgEv21ASIR/RsAIBH9GwFqIBH9GwJqIBH9GwNqIgo2AgAgCiAOIAogDkgbIQ4gCiANIAogDUobIQ0gAkEBaiICIAtHDQALDAILAn8gBSoCGLtEAAAAAABAj0CiIhCZRAAAAAAAAOBBYwRAIBCqDAELQYCAgIB4CyEKAn8gBSoCCLtEAAAAAABAj0CiIhCZRAAAAAAAAOBBYwRAIBCqDAELQYCAgIB4CyECAn8gBSoCKLtEAAAAAABAj0CiIhCZRAAAAAAAAOBBYwRAIBCqDAELQYCAgIB4CyEFQfj///8HIQ5BiICAgHghDSALIAxNDQEgAv0RIAr9HAEgBf0cAiESIAwhBQNAIAMgBUECdCICaiABIAAgAmooAgBBBHRq/QAAACAS/bUBIhH9GwAgEf0bAWogEf0bAmoiAjYCACACIA4gAiAOSBshDiACIA0gAiANShshDSAFQQFqIgUgC0cNAAsMAQsgDQRAQfj///8HIQ5BiICAgHghDSALIAxNDQEgDCEBA0AgAyABQQJ0IgVqAn8gAiAAIAVqKAIAQQJ0aioCALtEAAAAAAAAsECiIhCZRAAAAAAAAOBBYwRAIBCqDAELQYCAgIB4CyIKNgIAIAogDiAKIA5IGyEOIAogDSAKIA1KGyENIAFBAWoiASALRw0ACwwBCwJAIA9FBEAgCyAMSw0BQYiAgIB4IQ1B+P///wchDgwCC0H4////ByEOQYiAgIB4IQ0gCyAMTQ0BQX8hDyAMIQIDQCAPIAcgACACQQJ0IhRqKAIAQQJ0IhVqKAIAIgpHBEAgBf0JAgggCCAKQQZ0aiIP/QkCACAPKgIQ/SABIA8qAiD9IAIgDyoCMP0gA/3mASAF/QkCGCAP/QkCBCAPKgIU/SABIA8qAiT9IAIgDyoCNP0gA/3mAf3kASAF/QkCKCAP/QkCCCAPKgIY/SABIA8qAij9IAIgDyoCOP0gA/3mAf3kASAF/QkCOCAP/QkCDCAPKgIc/SABIA8qAiz9IAIgDyoCPP0gA/3mAf3kASERIAohDwsgAyAUagJ/IBEgASAVQQJ0IgpqKQIA/RL95gEiEv0fACAS/R8BkiARIBH9DQgJCgsMDQ4PAAAAAAAAAAAgASAKQQhyaikCAP0S/eYBIhL9HwCSIBL9HwGSu0QAAAAAAACwQKIiEJlEAAAAAAAA4EFjBEAgEKoMAQtBgICAgHgLIgo2AgAgCiAOIAogDkgbIQ4gCiANIAogDUobIQ0gAkEBaiICIAtHDQALDAELIAUqAighFiAFKgIYIRcgBSoCCCEYQfj///8HIQ5BiICAgHghDSAMIQUDQAJ/IBggASAAIAVBAnQiB2ooAgBBBHRqIgIqAgCUIBcgAioCBJSSIBYgAioCCJSSu0QAAAAAAACwQKIiEJlEAAAAAAAA4EFjBEAgEKoMAQtBgICAgHgLIQogAyAHaiAKNgIAIAogDiAKIA5IGyEOIAogDSAKIA1KGyENIAVBAWoiBSALRw0ACwsgCyAMSwRAIAlBAWuzIA2yIA6yk5UhFiAMIQ0DQAJ/IBYgAyANQQJ0aiIBKAIAIA5rspQiF4tDAAAAT10EQCAXqAwBC0GAgICAeAshCiABIAo2AgAgBCAKQQJ0aiIBIAEoAgBBAWo2AgAgDUEBaiINIAtHDQALCyAJQQJPBEAgBCgCACENQQEhDgNAIAQgDkECdGoiASABKAIAIA1qIg02AgAgDkEBaiIOIAlHDQALCyAMQQBKBEAgDCEOA0AgBiAOQQFrIgFBAnQiAmogACACaigCADYCACAOQQFKIQIgASEOIAINAAsLIAsgDEoEQCALIQ4DQCAGIAsgBCADIA5BAWsiDkECdCIBaigCAEECdGoiAigCACIFa0ECdGogACABaigCADYCACACIAVBAWs2AgAgDCAOSA0ACwsLBABBAAs="),i=new Uint8Array(o.length);for(let e=0;e<o.length;e++)i[e]=o.charCodeAt(e);return r.postMessage({init:{sorterWasmBytes:i.buffer,splatCount:e,useSharedMemory:t,integerBasedSort:n,dynamicMode:s,Constants:{BytesPerFloat:E.BytesPerFloat,BytesPerInt:E.BytesPerInt,DepthMapRange:E.DepthMapRange,MemoryPageSize:E.MemoryPageSize,MaxScenes:E.MaxScenes}}}),r}(r,this.sharedMemoryForWorkers,this.integerBasedSort,this.splatMesh.dynamicMode);let o=0;this.sortWorker.onmessage=e=>{if(e.data.sortDone){if(this.sortRunning=!1,this.sharedMemoryForWorkers)this.splatMesh.updateRenderIndexes(this.sortWorkerSortedIndexes,e.data.splatRenderCount);else{const t=new Uint32Array(e.data.sortedIndexes.buffer,0,e.data.splatRenderCount);this.splatMesh.updateRenderIndexes(t,e.data.splatRenderCount)}this.lastSortTime=e.data.sortTime,this.sortPromiseResolver(),this.sortPromise=null,this.sortPromiseResolver=null,this.forceRenderNextFrame(),0===o&&(this.runAfterFirstSort.forEach((e=>{e()})),this.runAfterFirstSort.length=0),o++}else if(e.data.sortCanceled)this.sortRunning=!1;else if(e.data.sortSetupPhase1Complete){console.log("Sorting web worker WASM setup complete."),this.sharedMemoryForWorkers?(this.sortWorkerSortedIndexes=new Uint32Array(e.data.sortedIndexesBuffer,e.data.sortedIndexesOffset,r),this.sortWorkerIndexesToSort=new Uint32Array(e.data.indexesToSortBuffer,e.data.indexesToSortOffset,r),this.sortWorkerPrecomputedDistances=new n(e.data.precomputedDistancesBuffer,e.data.precomputedDistancesOffset,r),this.sortWorkerTransforms=new Float32Array(e.data.transformsBuffer,e.data.transformsOffset,16*E.MaxScenes)):(this.sortWorkerIndexesToSort=new Uint32Array(r),this.sortWorkerPrecomputedDistances=new n(r),this.sortWorkerTransforms=new Float32Array(16*E.MaxScenes));for(let e=0;e<s;e++)this.sortWorkerIndexesToSort[e]=e;this.sortWorker.maxSplatCount=r,t()}else if(e.data.sortSetupComplete){console.log("Sorting web worker ready.");const e=this.splatMesh.getSplatDataTextures(),t=e.covariances.size,n=e.centerColors.size;console.log("Covariances texture size: "+t.x+" x "+t.y),console.log("Centers/colors texture size: "+n.x+" x "+n.y)}}}))}start(){if(!this.selfDrivenMode)throw new Error("Cannot start viewer unless it is in self driven mode.");this.webXRMode?this.renderer.setAnimationLoop(this.selfDrivenUpdateFunc):this.requestFrameId=requestAnimationFrame(this.selfDrivenUpdateFunc),this.selfDrivenModeRunning=!0}stop(){this.selfDrivenMode&&this.selfDrivenModeRunning&&(this.webXRMode||cancelAnimationFrame(this.requestFrameId),this.selfDrivenModeRunning=!1)}async dispose(){this.disposing=!0;let e=[],t=[];for(let n in this.downloadPromisesToAbort)if(this.downloadPromisesToAbort.hasOwnProperty(n)){const s=this.downloadPromisesToAbort[n];t.push(s),e.push(s.promise)}this.sortPromise&&e.push(this.sortPromise);const n=Promise.all(e).finally((()=>{this.stop(),this.controls&&(this.controls.dispose(),this.controls=null),this.splatMesh&&(this.splatMesh.dispose(),this.splatMesh=null),this.sceneHelper&&(this.sceneHelper.dispose(),this.sceneHelper=null),this.resizeObserver&&(this.resizeObserver.unobserve(this.rootElement),this.resizeObserver=null),this.disposeSortWorker(),this.removeEventHandlers(),this.loadingSpinner.removeAllTasks(),this.loadingSpinner.setContainer(null),this.loadingProgressBar.hide(),this.loadingProgressBar.setContainer(null),this.infoPanel.setContainer(null),this.camera=null,this.threeScene=null,this.splatRenderingInitialized=!1,this.initialized=!1,this.renderer&&(this.usingExternalRenderer||(this.rootElement.removeChild(this.renderer.domElement),this.renderer.dispose()),this.renderer=null),this.usingExternalRenderer||document.body.removeChild(this.rootElement),this.sortWorkerSortedIndexes=null,this.sortWorkerIndexesToSort=null,this.sortWorkerPrecomputedDistances=null,this.sortWorkerTransforms=null,this.disposed=!0,this.disposing=!1}));return t.forEach((e=>{e.abort()})),n}selfDrivenUpdate(){this.selfDrivenMode&&!this.webXRMode&&(this.requestFrameId=requestAnimationFrame(this.selfDrivenUpdateFunc)),this.update(),this.shouldRender()?(this.render(),this.consecutiveRenderFrames++):this.consecutiveRenderFrames=0,this.renderNextFrame=!1}forceRenderNextFrame(){this.renderNextFrame=!0}shouldRender=function(){let e=0;const t=new s.Vector3,n=new s.Quaternion,r=1e-4;return function(){let s=!1,o=!1;if(this.camera){const e=this.camera.position,s=this.camera.quaternion;o=Math.abs(e.x-t.x)>r||Math.abs(e.y-t.y)>r||Math.abs(e.z-t.z)>r||Math.abs(s.x-n.x)>r||Math.abs(s.y-n.y)>r||Math.abs(s.z-n.z)>r||Math.abs(s.w-n.w)>r}return s=this.renderMode!==ye.Never&&(0===e||this.splatMesh.visibleRegionChanging||o||this.renderMode===ye.Always||!0===this.dynamicMode||this.renderNextFrame),this.camera&&(t.copy(this.camera.position),n.copy(this.camera.quaternion)),e++,s}}();render=function(){if(!this.initialized||!this.splatRenderingInitialized)return;const e=this.renderer.autoClear;this.renderer.autoClear=!1,(e=>{for(let t of e.children)if(t.visible)return!0;return!1})(this.threeScene)&&this.renderer.render(this.threeScene,this.camera),this.renderer.render(this.splatMesh,this.camera),this.sceneHelper.getFocusMarkerOpacity()>0&&this.renderer.render(this.sceneHelper.focusMarker,this.camera),this.showControlPlane&&this.renderer.render(this.sceneHelper.controlPlane,this.camera),this.renderer.autoClear=e};update(e,t){this.dropInMode&&this.updateForDropInMode(e,t),this.initialized&&this.splatRenderingInitialized&&(this.controls&&this.controls.update(),this.splatMesh.updateVisibleRegionFadeDistance(this.sceneRevealMode),this.updateSplatSort(),this.updateForRendererSizeChanges(),this.updateSplatMesh(),this.updateMeshCursor(),this.updateFPS(),this.timingSensitiveUpdates(),this.updateInfoPanel(),this.updateControlPlane())}updateForDropInMode(e,t){this.renderer=e,this.splatMesh&&this.splatMesh.setRenderer(this.renderer),this.camera=t,this.controls&&(this.controls.object=t),this.init()}updateFPS=function(){let e=d(),t=0;return function(){if(this.consecutiveRenderFrames>60){const n=d();n-e>=1?(this.currentFPS=t,t=0,e=n):t++}else this.currentFPS=null}}();updateForRendererSizeChanges=function(){const e=new s.Vector2,t=new s.Vector2;return function(){this.renderer.getSize(t),t.x===e.x&&t.y===e.y||(this.usingExternalCamera||(this.camera.aspect=t.x/t.y,this.camera.updateProjectionMatrix()),e.copy(t))}}();timingSensitiveUpdates=function(){let e;return function(){const t=d();e||(e=t);const n=t-e;this.updateCameraTransition(t),this.updateFocusMarker(n),e=t}}();updateCameraTransition=function(){let e=new s.Vector3,t=new s.Vector3,n=new s.Vector3;return function(s){if(this.transitioningCameraTarget){t.copy(this.previousCameraTarget).sub(this.camera.position).normalize(),n.copy(this.nextCameraTarget).sub(this.camera.position).normalize();const r=Math.acos(t.dot(n)),o=(r/(Math.PI/3)*.65+.3)/r*(s-this.transitioningCameraTargetStartTime);e.copy(this.previousCameraTarget).lerp(this.nextCameraTarget,o),this.camera.lookAt(e),this.controls.target.copy(e),o>=1&&(this.transitioningCameraTarget=!1)}}}();updateFocusMarker=function(){const e=new s.Vector2;let t=!1;return function(n){if(this.getRenderDimensions(e),this.transitioningCameraTarget){this.sceneHelper.setFocusMarkerVisibility(!0);const s=Math.max(this.sceneHelper.getFocusMarkerOpacity(),0);let r=Math.min(s+10*n,1);this.sceneHelper.setFocusMarkerOpacity(r),this.sceneHelper.updateFocusMarker(this.nextCameraTarget,this.camera,e),t=!0,this.forceRenderNextFrame()}else{let s;if(s=t?1:Math.min(this.sceneHelper.getFocusMarkerOpacity(),1),s>0){this.sceneHelper.updateFocusMarker(this.nextCameraTarget,this.camera,e);let t=Math.max(s-2.5*n,0);this.sceneHelper.setFocusMarkerOpacity(t),0===t&&this.sceneHelper.setFocusMarkerVisibility(!1)}s>0&&this.forceRenderNextFrame(),t=!1}}}();updateMeshCursor=function(){const e=[],t=new s.Vector2;return function(){this.showMeshCursor?(this.forceRenderNextFrame(),this.getRenderDimensions(t),e.length=0,this.raycaster.setFromCameraAndScreenPosition(this.camera,this.mousePosition,t),this.raycaster.intersectSplatMesh(this.splatMesh,e),e.length>0?(this.sceneHelper.setMeshCursorVisibility(!0),this.sceneHelper.positionAndOrientMeshCursor(e[0].origin,this.camera)):this.sceneHelper.setMeshCursorVisibility(!1)):(this.sceneHelper.getMeschCursorVisibility()&&this.forceRenderNextFrame(),this.sceneHelper.setMeshCursorVisibility(!1))}}();updateInfoPanel=function(){const e=new s.Vector2;return function(){if(!this.showInfo)return;const t=this.splatMesh.getSplatCount();this.getRenderDimensions(e);const n=this.controls?this.controls.target:null,s=this.showMeshCursor?this.sceneHelper.meshCursor.position:null,r=this.splatRenderCount/t*100;this.infoPanel.update(e,this.camera.position,n,this.camera.up,s,this.currentFPS||"N/A",t,this.splatRenderCount,r,this.lastSortTime,this.focalAdjustment)}}();updateControlPlane(){this.showControlPlane?(this.sceneHelper.setControlPlaneVisibility(!0),this.sceneHelper.positionAndOrientControlPlane(this.controls.target,this.camera.up)):this.sceneHelper.setControlPlaneVisibility(!1)}updateSplatSort=function(){const e=new s.Matrix4,t=[],n=new s.Vector3(0,0,-1),r=new s.Vector3(0,0,-1),o=new s.Vector3,i=new s.Vector3,a=[],l=[{angleThreshold:.55,sortFractions:[.125,.33333,.75]},{angleThreshold:.65,sortFractions:[.33333,.66667]},{angleThreshold:.8,sortFractions:[.5]}];return async function(){if(this.sortRunning)return;if(!this.initialized||!this.splatRenderingInitialized)return;let s=0,c=0,d=!1,h=!1;if(r.set(0,0,-1).applyQuaternion(this.camera.quaternion),s=r.dot(n),c=i.copy(this.camera.position).sub(o).length(),!(this.forceSort||this.splatMesh.dynamicMode||0!==a.length||(s<=.99&&(d=!0),c>=1&&(h=!0),d||h)))return;this.sortRunning=!0;const{splatRenderCount:u,shouldSortAll:p}=this.gatherSceneNodesForSort();if(this.splatRenderCount=u,this.sortPromise=new Promise((e=>{this.sortPromiseResolver=e})),e.copy(this.camera.matrixWorld).invert(),e.premultiply(this.camera.projectionMatrix),e.multiply(this.splatMesh.matrixWorld),this.gpuAcceleratedSort&&(a.length<=1||a.length%2==0)&&await this.splatMesh.computeDistancesOnGPU(e,this.sortWorkerPrecomputedDistances),this.splatMesh.dynamicMode||p)a.push(this.splatRenderCount);else if(0===a.length){for(let e of l)if(s<e.angleThreshold){for(let t of e.sortFractions)a.push(Math.floor(this.splatRenderCount*t));break}a.push(this.splatRenderCount)}let m=Math.min(a.shift(),this.splatRenderCount);t[0]=this.camera.position.x,t[1]=this.camera.position.y,t[2]=this.camera.position.z;const f={modelViewProj:e.elements,cameraPosition:t,splatRenderCount:this.splatRenderCount,splatSortCount:m,usePrecomputedDistances:this.gpuAcceleratedSort};this.splatMesh.dynamicMode&&this.splatMesh.fillTransformsArray(this.sortWorkerTransforms),this.sharedMemoryForWorkers||(f.indexesToSort=this.sortWorkerIndexesToSort,f.transforms=this.sortWorkerTransforms,this.gpuAcceleratedSort&&(f.precomputedDistances=this.sortWorkerPrecomputedDistances)),this.sortWorker.postMessage({sort:f}),0===a.length&&(o.copy(this.camera.position),n.copy(r)),this.forceSort=!1}}();gatherSceneNodesForSort=function(){const e=[];let t=null;const n=new s.Vector3,r=new s.Vector3,o=new s.Vector3,i=new s.Matrix4,a=new s.Matrix4,l=new s.Matrix4,c=new s.Vector3,d=new s.Vector3(0,0,-1),h=new s.Vector3,u=e=>h.copy(e.max).sub(e.min).length();return function(h=!1){this.getRenderDimensions(c);const p=c.y/2/Math.tan(this.camera.fov/2*s.MathUtils.DEG2RAD),m=Math.atan(c.x/2/p),f=Math.atan(c.y/2/p),g=Math.cos(m),S=Math.cos(f),y=this.splatMesh.getSplatTree();if(y){a.copy(this.camera.matrixWorld).invert(),a.multiply(this.splatMesh.matrixWorld);let t=0,s=0;for(let c=0;c<y.subTrees.length;c++){const p=y.subTrees[c];i.copy(a),this.splatMesh.dynamicMode&&(this.splatMesh.getSceneTransform(c,l),i.multiply(l));const m=p.nodesWithIndexes.length;for(let a=0;a<m;a++){const l=p.nodesWithIndexes[a];if(!l.data||!l.data.indexes||0===l.data.indexes.length)continue;o.copy(l.center).applyMatrix4(i);const c=o.length();o.normalize(),n.copy(o).setX(0).normalize(),r.copy(o).setY(0).normalize();const m=d.dot(r),f=d.dot(n),y=u(l);!h&&(m<g-.6||f<S-.6)&&c>y||(s+=l.data.indexes.length,e[t]=l,l.data.distanceToNode=c,t++)}}e.length=t,e.sort(((e,t)=>e.data.distanceToNode<t.data.distanceToNode?-1:1));let c=s*E.BytesPerInt;for(let n=0;n<t;n++){const t=e[n],s=t.data.indexes.length,r=s*E.BytesPerInt;new Uint32Array(this.sortWorkerIndexesToSort.buffer,c-r,s).set(t.data.indexes),c-=r}return{splatRenderCount:s,shouldSortAll:!1}}{const e=this.splatMesh.getSplatCount();if(!t||t.length!==e){t=new Uint32Array(e);for(let n=0;n<e;n++)t[n]=n}return this.sortWorkerIndexesToSort.set(t),{splatRenderCount:e,shouldSortAll:!0}}}}();getSplatMesh(){return this.splatMesh}getSplatScene(e){return this.splatMesh.getScene(e)}isMobile(){return navigator.userAgent.includes("Mobi")}}class Ce extends s.Group{constructor(e={}){super(),e.selfDrivenMode=!1,e.useBuiltInControls=!1,e.rootElement=null,e.ignoreDevicePixelRatio=!1,e.dropInMode=!0,e.camera=void 0,e.renderer=void 0,this.viewer=new Ae(e),this.callbackMesh=Ce.createCallbackMesh(),this.add(this.callbackMesh),this.callbackMesh.onBeforeRender=Ce.onBeforeRender.bind(this,this.viewer)}addSplatScene(e,t={}){!1!==t.showLoadingUI&&(t.showLoadingUI=!0);const n=this.viewer.addSplatScene(e,t);return n.then((()=>{this.add(this.viewer.splatMesh)})),n}addSplatScenes(e,t){!1!==t&&(t=!0);const n=this.viewer.addSplatScenes(e,t);return n.then((()=>{this.add(this.viewer.splatMesh)})),n}getSplatScene(e){return this.viewer.getSplatScene(e)}dispose(){return this.viewer.dispose()}static onBeforeRender(e,t,n,s){e.update(t,s)}static createCallbackMesh(){const e=new s.SphereGeometry(1,8,8),t=new s.MeshBasicMaterial;t.colorWrite=!1,t.depthWrite=!1;const n=new s.Mesh(e,t);return n.frustumCulled=!1,n}}e.AbortablePromise=o,e.CompressedPlyParser=b,e.DropInViewer=Ce,e.KSplatLoader=k,e.LoaderUtils=z,e.OrbitControls=W,e.PlyLoader=I,e.PlyParser=w,e.RenderMode=ye,e.SceneFormat=O,e.SceneRevealMode=de,e.SplatBuffer=p,e.SplatBufferGenerator=v,e.SplatLoader=R,e.SplatParser=D,e.SplatPartitioner=T,e.Viewer=Ae,e.WebXRMode=fe}));
//# sourceMappingURL=gaussian-splats-3d.umd.min.cjs.map
